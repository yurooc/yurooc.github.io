<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Python基础面经 | YuBlog</title>
<meta name="keywords" content="Python">
<meta name="description" content="Python面经">
<meta name="author" content="Yu">
<link rel="canonical" href="https://yurooc.github.io/blog/python%E5%9F%BA%E7%A1%80/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.678b5c47efa744d2e0dd0d61101075e6aecdc9a0631e7ad8538f4ec0cca79273.css" integrity="sha256-Z4tcR&#43;&#43;nRNLg3Q1hEBB15q7NyaBjHnrYU49OwMynknM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://yurooc.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yurooc.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yurooc.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yurooc.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://yurooc.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Python基础面经" />
<meta property="og:description" content="Python面经" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yurooc.github.io/blog/python%E5%9F%BA%E7%A1%80/" /><meta property="article:section" content="Blog" />
<meta property="article:published_time" content="2023-11-25T00:31:00+08:00" />
<meta property="article:modified_time" content="2023-11-25T00:31:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python基础面经"/>
<meta name="twitter:description" content="Python面经"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blogs",
      "item": "https://yurooc.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Python基础面经",
      "item": "https://yurooc.github.io/blog/python%E5%9F%BA%E7%A1%80/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python基础面经",
  "name": "Python基础面经",
  "description": "Python面经",
  "keywords": [
    "Python"
  ],
  "articleBody": "Python基础 1.python新式类和经典类的区别？ a. 在python里凡是继承了object的类，都是新式类\nb. Python3里只有新式类\nc. Python2里面继承object的是新式类，没有写父类的是经典类\nd. 经典类目前在Python里基本没有应用\ne. 保持class与type的统一对新式类的实例执行a.__class__与type(a)的结果是一致的，对于旧式类来说就不一样了。\nf. 对于多重继承的属性搜索顺序不一样新式类是采用广度优先搜索，旧式类采用深度优先搜索。\n2.python中内置的数据结构有几种？ a. 整型 int、 长整型 long、浮点型 float、 复数 complex\nb. 字符串 str、 列表 list、 元组 tuple\nc. 字典 dict 、 集合 set\nd. Python3 中没有 long，只有无限精度的 int\n3.python如何实现单例模式?请写出两种实现方式? 第一种方法:使用装饰器\ndef singleton(cls): instances = {} def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class Foo(object): pass foo1 = Foo() foo2 = Foo() print(foo1 is foo2) # True 第二种方法：使用基类 New 是真正创建实例对象的方法，所以重写基类的new 方法，以此保证创建对象的时候只生成一个实例\nclass Singleton(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, '_instance'): cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs) return cls._instance class Foo(Singleton): pass foo1 = Foo() foo2 = Foo() print(foo1 is foo2) # True 第三种方法：元类，元类是用于创建类对象的类，类对象创建实例对象时一定要调用call方法，因此在调用call时候保证始终只创建一个实例即可，type是python的元类\nclass Singleton(type): def __call__(cls, *args, **kwargs): if not hasattr(cls, '_instance'): cls._instance = super(Singleton, cls).__call__(*args, **kwargs) return cls._instance # Python2 class Foo(object): __metaclass__ = Singleton # Python3 class Foo(metaclass=Singleton): pass foo1 = Foo() foo2 = Foo() print(foo1 is foo2) # True 4.可变类型和不可变类型 1,可变类型有list,dict.不可变类型有string,number,tuple.\n2,当进行修改操作时，可变类型传递的是内存中的地址，也就是说，直接修改内存中的值，并没有开辟新的内存。\n3,不可变类型被改变时，并没有改变原内存地址中的值，而是开辟一块新的内存，将原地址中的值复制过去，对这块新开辟的内存中的值进行操作。\n5.is和==有什么区别？ is：比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象。是否指向同一个内存地址\n== ： 比较的两个对象的内容/值是否相等，默认会调用对象的eq()方法\n6.Python中变量的作用域？（变量查找顺序) 函数作用域的LEGB顺序\n1.什么是LEGB?\nL: local 函数内部作用域\nE: enclosing 函数内部与内嵌函数之间\nG: global 全局作用域\nB: build-in 内置作用\npython在函数里面的查找分为4种，称之为LEGB，也正是按照这是顺序来查找的\n7.super函数的具体用法和场景 https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p07_calling_method_on_parent_class.html\nPython高级 元类 1.Python中类方法、类实例方法、静态方法有何区别？ 类方法: 是类对象的方法，在定义时需要在上方使用 @classmethod 进行装饰,形参为cls，表示类对象，类对象和实例对象都可调用\n类实例方法: 是类实例化对象的方法,只有实例对象可以调用，形参为self,指代对象本身;\n静态方法: 是一个任意函数，在其上方使用 @staticmethod 进行装饰，可以用对象直接调用，静态方法实际上跟该类没有太大关系\n2.介绍Cython，Pypy Cpython Numba各有什么缺点 Cython\n3.请描述抽象类和接口类的区别和联系 1.抽象类： 规定了一系列的方法，并规定了必须由继承类实现的方法。由于有抽象方法的存在，所以抽象类不能实例化。可以将抽象类理解为毛坯房，门窗，墙面的样式由你自己来定，所以抽象类与作为基类的普通类的区别在于约束性更强\n2.接口类：与抽象类很相似，表现在接口中定义的方法，必须由引用类实现，但他与抽象类的根本区别在于用途：与不同个体间沟通的规则，你要进宿舍需要有钥匙，这个钥匙就是你与宿舍的接口，你的舍友也有这个接口，所以他也能进入宿舍，你用手机通话，那么手机就是你与他人交流的接口\n3.区别和关联：\n1.接口是抽象类的变体，接口中所有的方法都是抽象的，而抽象类中可以有非抽象方法，抽象类是声明方法的存在而不去实现它的类\n2.接口可以继承，抽象类不行\n3.接口定义方法，没有实现的代码，而抽象类可以实现部分方法\n4.接口中基本数据类型为static而抽象类不是\n什么是Python中的GIL？ 全局解释器锁 GIL，对于每一个进程都具有一个 GIL ，它的直接作用是限制单个进程中多线程的并行执行，使得即使在多核处理器上对于单个进程来说，在同一时刻运行的线程仅限一个。\nPython的多线程是伪多线程，无法利用多核资源，同一个时刻只有一个线程在真正的运行。\n内存管理与垃圾回收机制 1.哪些操作会导致Python内存溢出，怎么处理？ 2.关于Python内存管理,下列说法错误的是 B A,变量不必事先声明 B,变量无须先创建和赋值而直接使用\nC,变量无须指定类型 D,可以使用del释放资源\n3.Python的内存管理机制及调优手段？ 内存管理机制: 引用计数、垃圾回收、内存池\n引用计数：引用计数是一种非常高效的内存管理手段，当一个Python对象被引用时其引用计数增加1,\n当其不再被一个变量引用时则计数减1,当引用计数等于0时对象被删除。弱引用不会增加引用计数\n垃圾回收：\n1.引用计数\n引用计数也是一种垃圾收集机制，而且也是一种最直观、最简单的垃圾收集技术。当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1，如果引用被删除，对象的引用计数为0,那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了。\n2.标记清除\n标记清除主要是解决循环引用问题。\n标记清除算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。\n它分为两个阶段：第一阶段是标记阶段，GC 会把所有的 活动对象 打上标记，第二阶段是把那些没有标记的对象 非活动对象 进行回收。那么 GC 又是如何判断哪些是活动对象哪些是非活动对象的呢？\n对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。\n3.分代技术\n分代回收是一种以空间换时间的操作方式。\nPython 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python 将内存分为了 3“代”，分别为年轻代（第 0 代）、中年代（第 1 代）、老年代（第 2 代），他们对应的是 3 个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。\n调优手段\n1.手动垃圾回收\n2.调高垃圾回收阈值\n3.避免循环引用\n4.内存泄露是什么？如何避免？ 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。\n有__del__()函数的对象间的循环引用是导致内存泄露的主凶。不使用一个对象时使用: del object 来删除一个对象的引用计数就可以有效防止内存泄露问题。\n通过Python扩展模块gc 来查看不能回收的对象的详细信息。\n可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为0来判断是否内存泄露\n函数 1.简述read、readline、readlines的区别？ read 读取整个文件\nreadline 读取下一行\nreadlines 读取整个文件到一个迭代器以供我们遍历\n2.什么是Hash（散列函数）？ 散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表\n3.python函数重载机制？ 函数重载主要是为了解决两个问题。 1。可变参数类型。 2。可变参数个数。\n另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。\n好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。\n那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。\n好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。\n4.函数调用参数的传递方式是值传递还是引用传递？ Python的参数传递有：位置参数、默认参数、可变参数、关键字参数。\n函数的传值到底是值传递还是引用传递、要分情况：\n不可变参数用值传递：像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。\n可变参数是引用传递：比如像列表，字典这样的对象是通过引用传递、和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。\n5.如何在function里面设置一个全局变量 globals() # 返回包含当前作用余全局变量的字典。 global 变量 设置使用全局变量 6.对缺省参数的理解 ？ 缺省参数指在调用函数的时候没有传入参数的情况下，调用默认的参数，在调用函数的同时赋值时，所传入的参数会替代默认参数。\n*args是不定长参数，它可以表示输入参数是不确定的，可以是任意多个。\n**kwargs是关键字参数，赋值的时候是以键值对的方式，参数可以是任意多对在定义函数的时候\n不确定会有多少参数会传入时，就可以使用两个参数\n7.Mysql怎么限制IP访问？ 8.带参数的装饰器? 带定长参数的装饰器\ndef new_func(func): def wrappedfun(username, passwd): if username == 'root' and passwd == '123456789': print('通过认证') print('开始执行附加功能') return func() else: print('用户名或密码错误') return return wrappedfun @new_func def origin(): print('开始执行函数') origin('root','123456789') 带不定长参数的装饰器\ndef new_func(func): def wrappedfun(*parts): if parts: counts = len(parts) print('本系统包含 ', end='') for part in parts: print(part, ' ',end='') print('等', counts, '部分') return func() else: print('用户名或密码错误') return func() return wrappedfun 9.为什么函数名字可以当做参数用? Python中一切皆对象，函数名是函数在内存中的空间，也是一个对象\n10.map函数和reduce函数？ map(lambda x: x * x, [1, 2, 3, 4]) # 使用 lambda # [1, 4, 9, 16] reduce(lambda x, y: x * y, [1, 2, 3, 4]) # 相当于 ((1 * 2) * 3) * 4 # 24 11.回调函数，如何通信的? 回调函数是把函数的指针(地址)作为参数传递给另一个函数，将整个函数当作一个对象，赋值给调用的函数。\n12.Python主要的内置数据类型都有哪些？ print dir( ‘a ’) 的输出？ 内建类型：布尔类型，数字，字符串，列表，元组，字典，集合\n输出字符串’a’的内建方法\n13.hasattr() getattr() setattr() 函数使用详解？ hasattr(object,name)函数:\n判断一个对象里面是否有name属性或者name方法，返回bool值，有name属性（方法）返回True，否则返回False。\nclass function_demo(object): name = 'demo' def run(self): return \"hello function\" functiondemo = function_demo() res = hasattr(functiondemo, \"name\") # 判断对象是否有name属性，True res = hasattr(functiondemo, \"run\") # 判断对象是否有run方法，True res = hasattr(functiondemo, \"age\") # 判断对象是否有age属性，False print(res) getattr(object, name[,default])函数：\n获取对象object的属性或者方法，如果存在则打印出来，如果不存在，打印默认值，默认值可选。注意：如果返回的是对象的方法，则打印结果是：方法的内存地址，如果需要运行这个方法，可以在后面添加括号().\nfunctiondemo = function_demo() getattr(functiondemo, \"name\")# 获取name属性，存在就打印出来 --- demo getattr(functiondemo, \"run\") # 获取run 方法，存在打印出方法的内存地址 getattr(functiondemo, \"age\") # 获取不存在的属性，报错 getattr(functiondemo, \"age\", 18)# 获取不存在的属性，返回一个默认值 setattr(object, name, values)函数：\n给对象的属性赋值，若属性不存在，先创建再赋值\nclass function_demo(object): name = \"demo\" def run(self): return \"hello function\" functiondemo = function_demo() res = hasattr(functiondemo, \"age\") # 判断age属性是否存在，False print(res) setattr(functiondemo, \"age\", 18) # 对age属性进行赋值，无返回值 res1 = hasattr(functiondemo, \"age\") # 再次判断属性是否存在，True 综合使用\nclass function_demo(object): name = \"demo\" def run(self): return \"hello function\" functiondemo = function_demo() res = hasattr(functiondemo, \"addr\") # 先判断是否存在 if res: addr = getattr(functiondemo, \"addr\") print(addr) else: addr = getattr(functiondemo, \"addr\", setattr(functiondemo, \"addr\", \"北京首都\")) print(addr) 14.什么是lambda函数？ 有什么好处？ lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数\n1.lambda函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用，连名字都很随意的情况下\n2.匿名函数，一般用来给filter，map这样的函数式编程服务\n3.作为回调函数，传递给某些应用，比如消息处理\n15.递归函数停止的条件？ 递归的终止条件一般定义在递归函数内部，在递归调用前要做一个条件判断，根据判断的结果选择是继续调用自身，还是return，，返回终止递归。\n终止的条件：判断递归的次数是否达到某一限定值\n2.判断运算的结果是否达到某个范围等，根据设计的目的来选择\n16.什么是lambda函数？它有什么好处？写一个匿名函数求两个数的和 lambda函数是匿名函数，使用lambda函数能创建小型匿名函数，这种函数得名于省略了用def声明函数的标准步骤\n设计模式 1.对设计模式的理解，简述你了解的设计模式？ 设计模式是经过总结，优化的，对我们经常会碰到的一些编程问题的可重用解决方案。一个设计模式并不像一个类或一个库那样能够直接作用于我们的代码，反之，设计模式更为高级，它是一种必须在特定情形下实现的一种方法模板。 常见的是工厂模式和单例模式\n2.请手写一个单例 #python2 class A(object): __instance = None def __new__(cls,*args,**kwargs): if cls.__instance is None: cls.__instance = objecet.__new__(cls) return cls.__instance else: return cls.__instance 3.单例模式的应用场景有那些？ 单例模式应用的场景一般发现在以下条件下： 资源共享的情况下，避免由于资源操作时导致的性能或损耗等，如日志文件，应用配置。 控制资源的情况下，方便资源之间的互相通信。如线程池等，1,网站的计数器 2,应用配置 3.多线程池 4数据库配置 数据库连接池 5.应用程序的日志应用…\n4.对装饰器的理解，并写出一个计时器记录方法执行性能的装饰器？ 装饰器本质上是一个callable object ，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。\nimport time from functools import wraps def timeit(func): @wraps(func) def wrapper(*args, **kwargs): start = time.clock() ret = func(*args, **kwargs) end = time.clock() print('used:',end-start) return ret return wrapper @timeit def foo(): print('in foo()'foo()) 5.解释以下什么是闭包？ 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。\n6.函数装饰器有什么作用？ 装饰器本质上是一个callable object，它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能。装饰器的返回值也是一个函数的对象，它经常用于有切面需求的场景。比如：插入日志，性能测试，事务处理，缓存。权限的校验等场景，有了装饰器就可以抽离出大量的与函数功能本身无关的雷同代码并发并继续使用。 详细参考：https://manjusaka.itscoder.com/2018/02/23/something-about-decorator/\n7.生成器，迭代器的区别？ 迭代器是遵循迭代协议的对象。用户可以使用 iter() 以从任何序列得到迭代器（如 list, tuple, dictionary, set 等）。另一个方法则是创建一个另一种形式的迭代器 —— generator 。要获取下一个元素，则使用成员函数 next()（Python 2）或函数 next() function （Python 3） 。当没有元素时，则引发 StopIteration 此例外。若要实现自己的迭代器，则只要实现 next()（Python 2）或 __next__()（ Python 3）\n生成器（Generator），只是在需要返回数据的时候使用yield语句。每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）\n区别： 生成器能做到迭代器能做的所有事，而且因为自动创建iter()和next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。\n官方介绍：https://docs.python.org/3/tutorial/classes.html#iterators\n8.Python中yield的用法? yield就是保存当前程序执行状态。你用for循环的时候，每次取一个元素的时候就会计算一次。用yield的函数叫generator,和iterator一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间，generator每次计算需要上一次计算结果，所以用yield,否则一return，上次计算结果就没了\n面向对象 1.Python中的可变对象和不可变对象？ 不可变对象，该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。\n可变对象，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上其所指的值直接发生改变，并没有发生复制行为，也没有开辟出新的地址，通俗点说就是原地改变。\nPyhton中，数值类型(int 和float)，字符串str、元组tuple都是不可变类型。而列表list、字典dict、集合set是可变类型\n2.Python的魔法方法 魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被Python所调用，你可以定义自己想要的行为，而这一切都是自动发生的，它们经常是两个下划线包围来命名的（比如__init___,__len__),Python的魔法方法是非常强大的所以了解其使用方法也变得尤为重要!\n__init__构造器，当一个实例被创建的时候初始化的方法，但是它并不是实例化调用的第一个方法。\n__new__才是实例化对象调用的第一个方法，它只取下cls参数，并把其他参数传给__init___.\n___new__很少使用，但是也有它适合的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。\n__call__让一个类的实例像函数一样被调用\n__getitem__定义获取容器中指定元素的行为，相当于self[key]\n__getattr__定义当用户试图访问一个不存在属性的时候的行为。\n__setattr__定义当一个属性被设置的时候的行为\n__getattribute___定义当一个属性被访问的时候的行为\n3.面向对象中怎么实现只读属性? 将对象私有化，通过共有方法提供一个读取数据的接口\nclass person: def __init__(self, x): self.__age = 10 def age(self): return self.__age t = person(22) # t.__age =100 print(t.age()) 最好的方法\nclass MyCls(object): __weight = 50 @property def weight(self): return self.__weight 4.谈谈你对面向对象的理解？ 面向对象是相当于面向过程而言的，面向过程语言是一种基于功能分析的，以算法为中心的程序设计方法，而面向对象是一种基于结构分析的，以数据为中心的程序设计思想。在面向对象语言中有一个很重要的东西，叫做类。面向对象有三大特性：封装、继承、多态。\n5.Python字符串查找和替换？ a、str.find()：正序字符串查找函数 函数原型： str.find(substr [,pos_start [,pos_end ] ] ) 返回str中第一次出现的substr的第一个字母的标号，如果str中没有substr则返回-1，也就是说从左边算起的第一次出现的substr的首字母标号。 参数说明： str：代表原字符串 substr：代表要查找的字符串 pos_start：代表查找的开始位置，默认是从下标0开始查找 pos_end：代表查找的结束位置 例子： 'aabbcc.find('bb')' # 2 b、str.index()：正序字符串查找函数 index()函数类似于find()函数，在Python中也是在字符串中查找子串第一次出现的位置，跟find()不同的是，未找到则抛出异常。 函数原型： str.index(substr [, pos_start, [ pos_end ] ] ) 参数说明： str：代表原字符串 substr：代表要查找的字符串 pos_start：代表查找的开始位置，默认是从下标0开始查找 pos_end：代表查找的结束位置 例子： 'acdd l1 23'.index(' ') # 4 c、str.rfind()：倒序字符串查找函数 函数原型： str.rfind( substr [, pos_start [,pos_ end ] ]) 返回str中最后出现的substr的第一个字母的标号，如果str中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号。 参数说明： str：代表原字符串 substr：代表要查找的字符串 pos_start：代表查找的开始位置，默认是从下标0开始查找 pos_end：代表查找的结束位置 例子： 'adsfddf'.rfind('d') # 5 d、str.rindex()：倒序字符串查找函数 rindex()函数类似于rfind()函数，在Python中也是在字符串中倒序查找子串最后一次出现的位置，跟rfind()不同的是，未找到则抛出异常。 函数原型： str.rindex(substr [, pos_start, [ pos_end ] ] ) 参数说明： str：代表原字符串 substr：代表要查找的字符串 pos_start：代表查找的开始位置，默认是从下标0开始查找 pos_end：代表查找的结束位置 例子： 'adsfddf'.rindex('d') # 5 e、使用re模块进行查找和替换： 函数 说明 re.match(pat, s) 只从字符串s的头开始匹配，比如(‘123’, ‘12345’)匹配上了，而(‘123’,’01234’)就是没有匹配上，没有匹配上返回None，匹配上返回matchobject re.search(pat, s) 从字符串s的任意位置都进行匹配，比如(‘123’,’01234’)就是匹配上了，只要s只能存在符合pat的连续字符串就算匹配上了，没有匹配上返回None，匹配上返回matchobject re.sub(pat,newpat,s) re.sub(pat,newpat,s)\t对字符串中s的包含的所有符合pat的连续字符串进行替换，如果newpat为str,那么就是替换为newpat,如果newpat是函数，那么就按照函数返回值替换。sub函数两个有默认值的参数分别是count表示最多只处理前几个匹配的字符串，默认为0表示全部处理；最后一个是flags，默认为0 f、使用replace()进行替换： 基本用法：对象.replace(rgExp,replaceText,max) 其中，rgExp和replaceText是必须要有的，max是可选的参数，可以不加。 rgExp是指正则表达式模式或可用标志的正则表达式对象，也可以是 String 对象或文字； replaceText是一个String 对象或字符串文字； max是一个数字。 对于一个对象，在对象的每个rgExp都替换成replaceText，从左到右最多max次。 s1='hello world' s1.replace('world','liming') 6.用Python匹配HTML tag的时候，\u003c.\u003e 和 \u003c.?\u003e 有什么区别 第一个代表贪心匹配，第二个代表非贪心； ?在一般正则表达式里的语法是指的\"零次或一次匹配左边的字符或表达式\"相当于{0,1} 而当?后缀于*,+,?,{n},{n,},{n,m}之后，则代表非贪心匹配模式，也就是说，尽可能少的匹配左边的字符或表达式，这里是尽可能少的匹配.(任意字符) 所以：第一种写法是，尽可能多的匹配，就是匹配到的字符串尽量长，第二中写法是尽可能少的匹配，就是匹配到的字符串尽量短。 比如tag\u003etag\u003eend，第一个会匹配tag\u003etag\u003e,第二个会匹配。 7.正则表达式贪婪与非贪婪模式的区别？ 贪婪模式： 定义：正则表达式去匹配时，会尽量多的匹配符合条件的内容 标识符：+，?，*，{n}，{n,}，{n,m} 匹配时，如果遇到上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容 非贪婪模式： 定义：正则表达式去匹配时，会尽量少的匹配符合条件的内容 也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有g，开启下一组匹配) 标识符：+?，??，*?，{n}?，{n,}?，{n,m}? 可以看到，非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个? 参考文章：https://dailc.github.io/2017/07/06/regularExpressionGreedyAndLazy.html 8.怎么过滤评论中的表情？ 思路：主要是匹配表情包的范围，将表情包的范围用空替换掉 import re pattern = re.compile(u'[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]') pattern.sub('',text) 9.简述Python里面search和match的区别 match()函数只检测字符串开头位置是否匹配，匹配成功才会返回结果，否则返回None； search()函数会在整个字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。 系统编程 1.进程总结 进程：程序运行在操作系统上的一个实例，就称之为进程。进程需要相应的系统资源：内存、时间片、pid。 创建进程： 首先要导入multiprocessing中的Process： 创建一个Process对象; 创建Process对象时，可以传递参数;\np = Process(target=XXX,args=(tuple,),kwargs={key:value}) target = XXX 指定的任务函数，不用加(), args=(tuple,)kwargs={key:value}给任务函数传递的参数 使用start()启动进程 结束进程 给子进程指定函数传递参数Demo\nimport os from mulitprocessing import Process import time def pro_func(name,age,**kwargs): for i in range(5): print(\"子进程正在运行中，name=%s,age=%d,pid=%d\"%(name,age,os.getpid())) print(kwargs) time.sleep(0.2) if __name__ ==\"__main__\": #创建Process对象 p = Process(target=pro_func,args=('小明',18),kwargs={'m':20}) #启动进程 p.start() time.sleep(1) #1秒钟之后，立刻结束子进程 p.terminate() p.join() 注意：进程间不共享全局变量\n进程之间的通信-Queue\n在初始化Queue()对象时（例如q=Queue(),若在括号中没有指定最大可接受的消息数量，获数量为负值时，那么就代表可接受的消息数量没有上限一直到内存尽头）\nQueue.qsize():返回当前队列包含的消息数量\nQueue.empty():如果队列为空，返回True，反之False\nQueue.full():如果队列满了，返回True,反之False\nQueue.get([block[,timeout]]):获取队列中的一条消息，然后将其从队列中移除，\nblock默认值为True。\n如果block使用默认值，且没有设置timeout（单位秒),消息队列如果为空，此时程序将被阻塞（停在读中状态），直到消息队列读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出“Queue.Empty\"异常：\nQueue.get_nowait()相当于Queue.get(False)\nQueue.put(item,[block[,timeout]]):将item消息写入队列，block默认值为True; 如果block使用默认值，且没有设置timeout（单位秒），消息队列如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息队列腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full\"异常 如果block值为False，消息队列如果没有空间可写入，则会立刻抛出\"Queue.Full\"异常; Queue.put_nowait(item):相当Queue.put(item,False)\n进程间通信Demo:\nfrom multiprocessing import Process.Queue import os,time,random #写数据进程执行的代码： def write(q): for value in ['A','B','C']: print(\"Put %s to queue...\",%value) q.put(value) time.sleep(random.random()) #读数据进程执行的代码 def read(q): while True: if not q.empty(): value = q.get(True) print(\"Get %s from queue.\",%value) time.sleep(random.random()) else: break if __name__=='__main__': #父进程创建Queue，并传给各个子进程 q = Queue() pw = Process(target=write,args=(q,)) pr = Process(target=read,args=(q,)) #启动子进程pw ，写入： pw.start() #等待pw结束 pw.join() #启动子进程pr，读取： pr.start() pr.join() #pr 进程里是死循环，无法等待其结束，只能强行终止: print('') print('所有数据都写入并且读完') 进程池Pool #coding:utf-8 from multiprocessing import Pool import os,time,random def worker(msg): t_start = time.time() print(\"%s 开始执行，进程号为%d\"%(msg,os.getpid())) # random.random()随机生成0-1之间的浮点数 time.sleep(random.random()*2) t_stop = time.time() print(msg,\"执行完毕，耗时%0.2f”%（t_stop-t_start)) po = Pool(3)#定义一个进程池，最大进程数3 for i in range(0,10): po.apply_async(worker,(i,)) print(\"---start----\") po.close() po.join() print(\"----end----\") 进程池中使用Queue\n如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue(),而不是multiprocessing.Queue(),否则会得到如下的错误信息：\nRuntimeError： Queue objects should only be shared between processs through inheritance\nfrom multiprocessing import Manager,Pool import os,time,random def reader(q): print(\"reader 启动(%s),父进程为（%s)\"%(os.getpid(),os.getpid())) for i in range(q.qsize()): print(\"reader 从Queue获取到消息:%s\"%q.get(True)) def writer(q): print(\"writer 启动（%s),父进程为(%s)\"%(os.getpid(),os.getpid())) for i in \"itcast\": q.put(i) if __name__ == \"__main__\": print(\"(%s)start\"%os.getpid()) q = Manager().Queue()#使用Manager中的Queue po = Pool() po.apply_async(wrtier,(q,)) time.sleep(1) po.apply_async(reader,(q,)) po.close() po.join() print(\"(%s)End\"%os.getpid()) 2.谈谈你对多进程，多线程，以及协程的理解，项目是否用？ 这个问题被问的概念相当之大， 进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。\n线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程，而多个线程共享内存（数据共享，共享全局变量),从而极大地提高了程序的运行效率。\n协程: 是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n3.Python异步使用场景有那些？ 异步的使用场景:\n1、 不涉及共享资源，获对共享资源只读，即非互斥操作\n2、 没有时序上的严格关系\n3、 不需要原子操作，或可以通过其他方式控制原子性\n4、 常用于IO操作等耗时操作，因为比较影响客户体验和使用性能\n5、 不影响主线程逻辑\n4.多线程共同操作同一个数据互斥锁同步？ import threading import time class MyThread(threading.Thread): def run(self): global num time.sleep(1) if mutex.acquire(1): num +=1 msg = self.name + 'set num to ' +str(num) print msg mutex.release() num = 0 mutex = threading.Lock() def test(): for i in range(5): t = MyThread() t.start() if __name__==\"__main__\": test() 5.什么是多线程竞争？ 线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即：数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全\n那么怎么解决多线程竞争问题？—锁\n锁的好处： 确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。\n锁的坏处： 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了\n锁的致命问题: 死锁\n6.请介绍一下Python的线程同步？ 一、 setDaemon(False) 当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，主线程会创建多个子线程，在Python中，默认情况下就是setDaemon(False),主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。\n例子\nimport threading import time def thread(): time.sleep(2) print('---子线程结束---') def main(): t1 = threading.Thread(target=thread) t1.start() print('---主线程--结束') if __name__ =='__main__': main() #执行结果 ---主线程--结束 ---子线程结束--- 二、 setDaemon（True) 当我们使用setDaemon(True)时，这是子线程为守护线程，主线程一旦执行结束，则全部子线程被强制终止\n例子\nimport threading import time def thread(): time.sleep(2) print(’---子线程结束---') def main(): t1 = threading.Thread(target=thread) t1.setDaemon(True)#设置子线程守护主线程 t1.start() print('---主线程结束---') if __name__ =='__main__': main() #执行结果 ---主线程结束--- #只有主线程结束，子线程来不及执行就被强制结束 三、 join（线程同步) join 所完成的工作就是线程同步，即主线程任务结束以后，进入堵塞状态，一直等待所有的子线程结束以后，主线程再终止。\n当设置守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序，所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和，简单的来说，就是给每个子线程一个timeou的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。\n没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。\n例子\nimport threading import time def thread(): time.sleep(2) print('---子线程结束---') def main(): t1 = threading.Thread(target=thread) t1.setDaemon(True) t1.start() t1.join(timeout=1)#1 线程同步，主线程堵塞1s 然后主线程结束，子线程继续执行 #2 如果不设置timeout参数就等子线程结束主线程再结束 #3 如果设置了setDaemon=True和timeout=1主线程等待1s后会强制杀死子线程，然后主线程结束 print('---主线程结束---') if __name__=='__main___': main() 7.解释以下什么是锁，有哪几种锁？ 锁(Lock)是python提供的对线程控制的对象。有互斥锁，可重入锁，死锁。\n8.什么是死锁？ 若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。\nGIL锁 全局解释器锁\n作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！\n所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。\n进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换\n三者的关系：进程里有线程，线程里有协程。\n9.多线程交互访问数据，如果访问到了就不访问了？ 怎么避免重读？\n创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。\n10.什么是线程安全，什么是互斥锁？ 每个对象都对应于一个可称为’互斥锁‘的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。\n同一进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。\n11.说说下面几个概念：同步，异步，阻塞，非阻塞？ 同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。\n异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！\n阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。\n非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。\n同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。\n12.什么是僵尸进程和孤儿进程？怎么避免僵尸进程？ 孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init 进程（进程号为1）所收养，并由init 进程对他们完成状态收集工作。\n僵尸进程： 进程使用fork 创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。\n避免僵尸进程的方法：\n1.fork 两次用孙子进程去完成子进程的任务\n2.用wait()函数使父进程阻塞\n3.使用信号量，在signal handler 中调用waitpid,这样父进程不用阻塞\n13.python中进程与线程的使用场景？ 多进程适合在CPU密集操作（cpu操作指令比较多，如位多的的浮点运算）。\n多线程适合在IO密性型操作（读写数据操作比多的的，比如爬虫）\n14.线程是并发还是并行，进程是并发还是并行？ 线程是并发，进程是并行;\n进程之间互相独立，是系统分配资源的最小单位，同一个进程中的所有线程共享资源。\n15.并行(parallel)和并发（concurrency)? 并行： 同一时刻多个任务同时在运行\n并发：不会在同一时刻同时运行，存在交替执行的情况。\n实现并行的库有： multiprocessing\n实现并发的库有: threading\n程序需要执行较多的读写、请求和回复任务的需要大量的IO操作，IO密集型操作使用并发更好。\nCPU运算量大的程序，使用并行会更好\n16.IO密集型和CPU密集型区别？ IO密集型： 系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写\nCPU密集型： 大部分时间用来做计算，逻辑判断等CPU动作的程序称之CPU密集型。\n17.python asyncio的原理？ asyncio这个库就是使用python的yield这个可以打断保存当前函数的上下文的机制， 封装好了selector 摆脱掉了复杂的回调关系\n网络编程 1.怎么实现强行关闭客户端和服务器之间的连接? 2.简述TCP和UDP的区别以及优缺点? 3.简述浏览器通过WSGI请求动态资源的过程? 浏览器发送的请求被Nginx监听到，Nginx根据请求的URL的PATH或者后缀把请求静态资源的分发到静态资源的目录，别的请求根据配置好的转发到相应端口。 实现了WSGI的程序会监听某个端口，监听到Nginx转发过来的请求接收后(一般用socket的recv来接收HTTP的报文)以后把请求的报文封装成environ的字典对象，然后再提供一个start_response的方法。把这两个对象当成参数传入某个方法比如wsgi_app(environ, start_response)或者实现了__call__(self, environ, start_response)方法的某个实例。这个实例再调用start_response返回给实现了WSGI的中间件，再由中间件返回给Nginx。\n4.描述用浏览器访问www.baidu.com的过程 5.Post和Get请求的区别? 6.cookie 和session 的区别？ 7.列出你知道的HTTP协议的状态码，说出表示什么意思？ 8.请简单说一下三次握手和四次挥手？ 9.说一下什么是tcp的2MSL？ 10.为什么客户端在TIME-WAIT状态必须等待2MSL的时间？ 11.说说HTTP和HTTPS区别？ 12.谈一下HTTP协议以及协议头部中表示数据类型的字段？ 13.HTTP请求方法都有什么？ 14.使用Socket套接字需要传入哪些参数 ？ 15.HTTP常见请求头？ 16.七层模型？ 17.url的形式？ Web Flask 1.对Flask蓝图(Blueprint)的理解？ 蓝图的定义\n蓝图 /Blueprint 是Flask应用程序组件化的方法，可以在一个应用内或跨越多个项目共用蓝图。使用蓝图可以极大简化大型应用的开发难度，也为Flask扩展提供了一种在应用中注册服务的集中式机制。\n蓝图的应用场景：\n把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。\n以URL前缀和/或子域名，在应用上注册一个蓝图。URL前缀/子域名中的参数即成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下） 在一个应用中用不同的URL规则多次注册一个蓝图。\n通过蓝图提供模板过滤器、静态文件、模板和其他功能。一个蓝图不一定要实现应用或视图函数。\n初始化一个Flask扩展时，在这些情况中注册一个蓝图。\n蓝图的缺点：\n不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。\n使用蓝图的三个步骤\n1.创建一个蓝图对象\nblue = Blueprint(\"blue\",__name__) 2.在这个蓝图对象上进行操作，例如注册路由、指定静态文件夹、注册模板过滤器…\n@blue.route('/') def blue_index(): return \"Welcome to my blueprint\" 3.在应用对象上注册这个蓝图对象\napp.register_blueprint(blue,url_prefix=\"/blue\") 2.Flask 和 Django 路由映射的区别？ 在django中，路由是浏览器访问服务器时，先访问的项目中的url，再由项目中的url找到应用中url，这些url是放在一个列表里，遵从从前往后匹配的规则。在flask中，路由是通过装饰器给每个视图函数提供的，而且根据请求方式的不同可以一个url用于不同的作用。\nDjango 1.什么是wsgi,uwsgi,uWSGI? WSGI:\nweb服务器网关接口，是一套协议。用于接收用户请求并将请求进行初次封装，然后将请求交给web框架。\n实现wsgi协议的模块：wsgiref,本质上就是编写一socket服务端，用于接收用户请求（django)\nwerkzeug,本质上就是编写一个socket服务端，用于接收用户请求(flask)\nuwsgi:\n与WSGI一样是一种通信协议，它是uWSGI服务器的独占协议，用于定义传输信息的类型。 uWSGI:\n是一个web服务器，实现了WSGI的协议，uWSGI协议，http协议\n2.Django、Flask、Tornado的对比？ 1、 Django走的大而全的方向，开发效率高。它的MTV框架，自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器，给开发者提高了超高的开发效率。 重量级web框架，功能齐全，提供一站式解决的思路，能让开发者不用在选择上花费大量时间。\n自带ORM和模板引擎，支持jinja等非官方模板引擎。\n自带ORM使Django和关系型数据库耦合度高，如果要使用非关系型数据库，需要使用第三方库\n自带数据库管理app\n成熟，稳定，开发效率高，相对于Flask，Django的整体封闭性比较好，适合做企业级网站的开发。python web框架的先驱，第三方库丰富\n2、 Flask 是轻量级的框架，自由，灵活，可扩展性强，核心基于Werkzeug WSGI工具 和jinja2 模板引擎\n适用于做小网站以及web服务的API,开发大型网站无压力，但架构需要自己设计\n与关系型数据库的结合不弱于Django，而与非关系型数据库的结合远远优于Django\n3、 Tornado走的是少而精的方向，性能优越，它最出名的异步非阻塞的设计方式\nTornado的两大核心模块：\niostraem:对非阻塞的socket进行简单的封装\nioloop: 对I/O 多路复用的封装,它实现一个单例\n3.CORS 和 CSRF的区别？ 什么是CORS？\nCORS是一个W3C标准,全称是“跨域资源共享\"(Cross-origin resoure sharing). 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\n什么是CSRF？\nCSRF主流防御方式是在后端生成表单的时候生成一串随机token,内置到表单里成为一个字段，同时，将此串token置入session中。每次表单提交到后端时都会检查这两个值是否一致，以此来判断此次表单提交是否是可信的，提交过一次之后，如果这个页面没有生成CSRF token,那么token将会被清空,如果有新的需求，那么token会被更新。 攻击者可以伪造POST表单提交，但是他没有后端生成的内置于表单的token，session中没有token都无济于事。\n4.Session,Cookie,JWT的理解 为什么要使用会话管理\n众所周知，HTTP协议是一个无状态的协议，也就是说每个请求都是一个独立的请求，请求与请求之间并无关系。但在实际的应用场景，这种方式并不能满足我们的需求。举个大家都喜欢用的例子，把商品加入购物车，单独考虑这个请求，服务端并不知道这个商品是谁的，应该加入谁的购物车？因此这个请求的上下文环境实际上应该包含用户的相关信息，在每次用户发出请求时把这一小部分额外信息，也做为请求的一部分，这样服务端就可以根据上下文中的信息，针对具体的用户进行操作。所以这几种技术的出现都是对HTTP协议的一个补充，使得我们可以用HTTP协议+状态管理构建一个的面向用户的WEB应用。\nSession 和Cookie的区别\n这里我想先谈谈session与cookies,因为这两个技术是做为开发最为常见的。那么session与cookies的区别是什么？个人认为session与cookies最核心区别在于额外信息由谁来维护。利用cookies来实现会话管理时，用户的相关信息或者其他我们想要保持在每个请求中的信息，都是放在cookies中,而cookies是由客户端来保存，每当客户端发出新请求时，就会稍带上cookies,服务端会根据其中的信息进行操作。 当利用session来进行会话管理时，客户端实际上只存了一个由服务端发送的session_id,而由这个session_id,可以在服务端还原出所需要的所有状态信息，从这里可以看出这部分信息是由服务端来维护的。\n除此以外，session与cookies都有一些自己的缺点：\ncookies的安全性不好，攻击者可以通过获取本地cookies进行欺骗或者利用cookies进行CSRF攻击。使用cookies时,在多个域名下，会存在跨域问题。 session 在一定的时间里，需要存放在服务端，因此当拥有大量用户时，也会大幅度降低服务端的性能，当有多台机器时，如何共享session也会是一个问题.(redis集群)也就是说，用户第一个访问的时候是服务器A，而第二个请求被转发给了服务器B，那服务器B如何得知其状态。实际上，session与cookies是有联系的，比如我们可以把session_id存放在cookies中的。\nJWT是如何工作的\n首先用户发出登录请求，服务端根据用户的登录请求进行匹配，如果匹配成功，将相关的信息放入payload中，利用算法，加上服务端的密钥生成token，这里需要注意的是secret_key很重要，如果这个泄露的话，客户端就可以随机篡改发送的额外信息，它是信息完整性的保证。生成token后服务端将其返回给客户端，客户端可以在下次请求时，将token一起交给服务端，一般是说我们可以将其放在Authorization首部中，这样也就可以避免跨域问题。\n5.简述Django请求生命周期 一般是用户通过浏览器向我们的服务器发起一个请求(request),这个请求会去访问视图函数，如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户） 视图函数调用模型毛模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。\n1.wsgi ,请求封装后交给web框架（Flask，Django)\n2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf,request.session\n3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数\n4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm，templates\n5.中间件，对响应的数据进行处理\n6.wsgi，将响应的内容发送给浏览器\n6.用的restframework完成api发送时间时区 当前的问题是用django的rest framework模块做一个get请求的发送时间以及时区信息的api\nclass getCurrenttime(APIView): def get(self,request): local_time = time.localtime() time_zone =settings.TIME_ZONE temp = {'localtime':local_time,'timezone':time_zone} return Response(temp) 7.nginx,tomcat,apach到都是什么？ Nginx（engine x)是一个高性能的HTTP和反向代理服务器，也是 一个IMAP/POP3/SMTP服务器，工作在OSI七层，负载的实现方式：轮询，IP_HASH,fair,session_sticky. Apache HTTP Server是一个模块化的服务器，源于NCSAhttpd服务器 Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，是开发和调试JSP程序的首选。\n8.请给出你熟悉关系数据库范式有哪些，有什么作用？ 在进行数据库的设计时，所遵循的一些规范，只要按照设计规范进行设计，就能设计出没有数据冗余和数据维护异常的数据库结构。\n数据库的设计的规范有很多，通常来说我们在设是数据库时只要达到其中一些规范就可以了，这些规范又称之为数据库的三范式，一共有三条，也存在着其他范式，我们只要做到满足前三个范式的要求，就能设陈出符合我们的数据库了，我们也不能全部来按照范式的要求来做，还要考虑实际的业务使用情况，所以有时候也需要做一些违反范式的要求。 1.数据库设计的第一范式(最基本)，基本上所有数据库的范式都是符合第一范式的，符合第一范式的表具有以下几个特点：\n数据库表中的所有字段都只具有单一属性，单一属性的列是由基本的数据类型（整型，浮点型，字符型等）所构成的设计出来的表都是简单的二比表\n2.数据库设计的第二范式(是在第一范式的基础上设计的)，要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系\n3.数据库设计的第三范式，指每一个非主属性既不部分依赖与也不传递依赖于业务主键，也就是第二范式的基础上消除了非主属性对主键的传递依赖\n9.简述QQ登陆过程 qq登录，在我们的项目中分为了三个接口，\n第一个接口是请求qq服务器返回一个qq登录的界面;\n第二个接口是通过扫码或账号登陆进行验证，qq服务器返回给浏览器一个code和state,利用这个code通过本地服务器去向qq服务器获取access_token覆返回给本地服务器，凭借access_token再向qq服务器获取用户的openid(openid用户的唯一标识)\n第三个接口是判断用户是否是第一次qq登录，如果不是的话直接登录返回的jwt-token给用户，对没有绑定过本网站的用户，对openid进行加密生成token进行绑定\n10.post 和 get的区别? 1.GET是从服务器上获取数据，POST是向服务器传送数据\n2.在客户端，GET方式在通过URL提交数据，数据在URL中可以看到，POST方式，数据放置在HTML——HEADER内提交\n3.对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据\n11.项目中日志的作用 一、日志相关概念\n1.日志是一种可以追踪某些软件运行时所发生事件的方法\n2.软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情\n3.一个事件可以用一个包含可选变量数据的消息来描述\n4.此外，事件也有重要性的概念，这个重要性也可以被成为严重性级别(level)\n二、日志的作用\n1.通过log的分析，可以方便用户了解系统或软件、应用的运行情况;\n2.如果你的应用log足够丰富，可以分析以往用户的操作行为、类型喜好，地域分布或其他更多信息;\n3.如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。\n4.简单来讲就是我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时快速定位问题。不仅在开发中，在运维中日志也很重要，日志的作用也可以简单。总结为以下几点：\n1.程序调试\n2.了解软件程序运行情况，是否正常\n3,软件程序运行故障分析与问题定位\n4,如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析\n12.django中间件的使用？ Django在中间件中预置了六个方法，这六个方法的区别在于不同的阶段执行，对输入或输出进行干预，方法如下：\n1.初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件\ndef __init__(): pass 2.处理请求前：在每个请求上调用，返回None或HttpResponse对象。\ndef process_request(request): pass 3.处理视图前:在每个请求上调用，返回None或HttpResponse对象。\ndef process_view(request,view_func,view_args,view_kwargs): pass 4.处理模板响应前：在每个请求上调用，返回实现了render方法的响应对象。\ndef process_template_response(request,response): pass 5.处理响应后：所有响应返回浏览器之前被调用，在每个请求上调用，返回HttpResponse对象。\ndef process_response(request,response): pass 6.异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个HttpResponse对象。\ndef process_exception(request,exception): pass 13.谈一下你对uWSGI和nginx的理解？ 1.uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。WSGI是一种Web服务器网关接口。它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如用Flask框架写的程序）通信的一种规范。\n要注意WSGI/uwsgi/uWSGI这三个概念的区分。\nWSGI是一种通信协议。\nuwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。\nuWSGI是实现了uwsgi和WSGI两种协议的Web服务器。\nnginx 是一个开源的高性能的HTTP服务器和反向代理：\n1.作为web服务器，它处理静态文件和索引文件效果非常高\n2.它的设计非常注重效率，最大支持5万个并发连接，但只占用很少的内存空间\n3.稳定性高，配置简洁。\n4.强大的反向代理和负载均衡功能，平衡集群中各个服务器的负载压力应用\n14.Python中三大框架各自的应用场景？ django:主要是用来搞快速开发的，他的亮点就是快速开发，节约成本，,如果要实现高并发的话，就要对django进行二次开发，比如把整个笨重的框架给拆掉自己写socket实现http的通信,底层用纯c,c++写提升效率，ORM框架给干掉，自己编写封装与数据库交互的框架,ORM虽然面向对象来操作数据库，但是它的效率很低，使用外键来联系表与表之间的查询; flask: 轻量级，主要是用来写接口的一个框架，实现前后端分离，提考开发效率，Flask本身相当于一个内核，其他几乎所有的功能都要用到扩展(邮件扩展Flask-Mail，用户认证Flask-Login),都需要用第三方的扩展来实现。比如可以用Flask-extension加入ORM、文件上传、身份验证等。Flask没有默认使用的数据库，你可以选择MySQL，也可以用NoSQL。\n其WSGI工具箱用Werkzeug(路由模块)，模板引擎则使用Jinja2,这两个也是Flask框架的核心。\nTornado： Tornado是一种Web服务器软件的开源版本。Tornado和现在的主流Web服务器框架（包括大多数Python的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其非阻塞的方式和对epoll的运用，Tornado每秒可以处理数以千计的连接因此Tornado是实时Web服务的一个理想框架\n15.Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？ 1.Django中耗时的任务用一个进程或者线程来执行，比如发邮件，使用celery.\n2.部署django项目是时候，配置文件中设置了进程和协程的相关配置。\n16.有用过Django REST framework吗？ Django REST framework是一个强大而灵活的Web API工具。使用RESTframework的理由有：\nWeb browsable API对开发者有极大的好处\n包括OAuth1a和OAuth2的认证策略\n支持ORM和非ORM数据资源的序列化\n全程自定义开发–如果不想使用更加强大的功能，可仅仅使用常规的function-based views额外的文档和强大的社区支持\n17.对cookies与session的了解？他们能单独用吗？ Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但是禁用Cookie就不能得到Session。因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于SessionID,也就得不到Session。\n爬虫 1.试列出至少三种目前流行的大型数据库 2.列举您使用过的Python网络爬虫所用到的网络数据包? requests, urllib,urllib2, httplib2\n3.爬取数据后使用哪个数据库存储数据的，为什么？ 4.你用过的爬虫框架或者模块有哪些？优缺点？ Python自带：urllib,urllib2\n第三方：requests\n框架： Scrapy\nurllib 和urllib2模块都做与请求URL相关的操作，但他们提供不同的功能。\nurllib2: urllib2.urlopen可以接受一个Request对象或者url,(在接受Request对象时，并以此可以来设置一个URL的headers),urllib.urlopen只接收一个url。\nurllib 有urlencode,urllib2没有，因此总是urllib, urllib2常会一起使用的原因\nscrapy是封装起来的框架，他包含了下载器，解析器，日志及异常处理，基于多线程，twisted的方式处理，对于固定单个网站的爬取开发，有优势，但是对于多网站爬取100个网站，并发及分布式处理不够灵活，不便调整与扩展\nrequests是一个HTTP库，它只是用来请求，它是一个强大的库，下载，解析全部自己处理，灵活性高\nScrapy优点：异步，xpath，强大的统计和log系统，支持不同url。shell方便独立调试。写middleware方便过滤。通过管道存入数据库\n5.写爬虫是用多进程好？还是多线程好？ 6.常见的反爬虫和应对方法？ 7.解析网页的解析器使用最多的是哪几个? 8.需要登录的网页，如何解决同时限制ip，cookie,session 9.验证码的解决? 10.使用最多的数据库，对他们的理解？ 11.编写过哪些爬虫中间件？ 12.“极验”滑动验证码如何破解？ 13.爬虫多久爬一次，爬下来的数据是怎么存储？ 14.cookie过期的处理问题？ 15.动态加载又对及时性要求很高怎么处理？ 16.HTTPS有什么优点和缺点？ 17.HTTPS是如何实现安全传输数据的？ 18.TTL，MSL，RTT各是什么？ 19.谈一谈你对Selenium和PhantomJS了解 20.平常怎么使用代理的 ？ 21.存放在数据库(redis、mysql等)。 22.怎么监控爬虫的状态? 23.描述下scrapy框架运行的机制？ 24.谈谈你对Scrapy的理解？ 25.怎么样让 scrapy 框架发送一个 post 请求（具体写出来） 26.怎么监控爬虫的状态 ？ 27.怎么判断网站是否更新？ 28.图片、视频爬取怎么绕过防盗连接 29.你爬出来的数据量大概有多大？大概多长时间爬一次？ 30.用什么数据库存爬下来的数据？部署是你做的吗？怎么部署？ 31.增量爬取 32.爬取下来的数据如何去重，说一下scrapy的具体的算法依据。 33.Scrapy的优缺点? 34.怎么设置爬取深度？ 35.scrapy和scrapy-redis有什么区别？为什么选择redis数据库？ 36.分布式爬虫主要解决什么问题？ 37.什么是分布式存储？ 38.你所知道的分布式爬虫方案有哪些？ 39.scrapy-redis，有做过其他的分布式爬虫吗？ 数据库 MySQL 1.主键 超键 候选键 外键 主键：数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值(Null).\n超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。\n候选键：是最小超键，即没有冗余元素的超键。\n外键：在一个表中存在的另一个表的主键称此表的外键。\n2.视图的作用，视图可以更改么？ 视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询;不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据;视图创建后，可以使用与表相同的方式利用它们。\n视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖。\n创建视图： create view xxx as xxxxxx\n对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新;但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。\n3.drop,delete与truncate的区别 drop直接删掉表，truncate删除表中数据，再插入时自增长id又从1开始，delete删除表中数据，可以加where字句。\n1.delete 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。truncate table则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器，执行速度快。\n2.表和索引所占空间。当表被truncate后，这个表和索引所占用的空间会恢复到初始大小，而delete操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。\n3.一般而言，drop\u003etruncate\u003edelete\n4.应用范围。truncate只能对table，delete可以是table和view\n5.truncate和delete只删除数据，而drop则删除整个表（结构和数据)\n6.truncate与不带where的delete:只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束(constrain),触发器（trigger)索引(index);依赖于该表的存储过程/函数将被保留，但其状态会变为:invalid.\n4.索引的工作原理及其种类 数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引的实现通常使用B树以其变种B+树。\n在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。\n为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间（因为索引也要随之变动）\n5.连接的种类 6.数据库优化的思路 7.存储过程与触发器的区别 8.悲观锁和乐观锁是什么？ 9.你常用的mysql引擎有哪些?各引擎间有什么区别? Redis 1.Redis宕机怎么解决? 宕机:服务器停止服务‘\n如果只有一台redis，肯定 会造成数据丢失，无法挽救\n多台redis或者是redis集群，宕机则需要分为在主从模式下区分来看：\nslave从redis宕机，配置主从复制的时候才配置从的redis，从的会从主的redis中读取主的redis的操作日志1，在redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据;\n2, 如果从数据库实现了持久化，此时千万不要立马重启服务，否则可能会造成数据丢失，正确的操作如下：在slave数据上执行SLAVEOF ON ONE,来断开主从关系并把slave升级为主库，此时重新启动主数据库，执行SLAVEOF，把它设置为从库，连接到主的redis上面做主从复制，自动备份数据。\n以上过程很容易配置错误，可以使用redis提供的哨兵机制来简化上面的操作。简单的方法:redis的哨兵(sentinel)的功能\n2.redis和mecached的区别，以及使用场景 区别\n1、redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可以用于缓存其他东西，例如图片，视频等等\n2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list,set,hash等数据结构的存储\n3、虚拟内存-redis当物流内存用完时，可以将一些很久没用的value交换到磁盘\n4、过期策略-memcache在set时就指定，例如set key1 0 0 8，即永不过期。Redis可以通过例如expire设定，例如expire name 10\n5、分布式-设定memcache集群，利用magent做一主多从，redis可以做一主多从。都可以一主一丛\n6、存储数据安全-memcache挂掉后，数据没了，redis可以定期保存到磁盘(持久化)\n7、灾难恢复-memcache挂掉后，数据不可恢复，redis数据丢失后可以通过aof恢复\n8、Redis支持数据的备份，即master-slave模式的数据备份\n9、应用场景不一样，redis除了作为NoSQL数据库使用外，还能用做消息队列，数据堆栈和数据缓存等;Memcache适合于缓存SQL语句，数据集，用户临时性数据，延迟查询数据和session等\n使用场景\n1,如果有持久方面的需求或对数据类型和处理有要求的应该选择redis\n2,如果简单的key/value存储应该选择memcached.\n3.Redis集群方案该怎么做?都有哪些方案? 1,codis\n目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在节点数量改变情况下，旧节点数据客恢复到新hash节点\n2redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方介绍\n3.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key进行hash计算，然后去对应的redis实例操作数据。这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的字典脚本恢复，实例的监控，等等\n4.Redis回收进程是如何工作的 一个客户端运行了新的命令，添加了新的数据。\nredis检查内存使用情况，如果大于maxmemory的限制，则根据设定好的策略进行回收。\n一个新的命令被执行等等，所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断回收回到边界以下。\n如果一个命令的结果导致大量内存被使用(例如很大的集合的交集保存到一个新的键)，不用多久内存限制就会被这个内存使用量超越。\nMongoDB 1.MongoDB中对多条记录做更新操作命令是什么？ 2.MongoDB如何才会拓展到多个shard里？ 测试 3.编写测试计划的目的是 4.对关键词触发模块进行测试 5.其他常用笔试题目网址汇总 6.测试人员在软件开发过程中的任务是什么 7.一条软件Bug记录都包含了哪些内容？ 8.简述黑盒测试和白盒测试的优缺点 9.请列出你所知道的软件测试种类，至少5项 10.Alpha测试与Beta测试的区别是什么？ 11.举例说明什么是Bug？一个bug report应包含什么关键字？ 大数据 1.找出1G的文件中高频词 2.一个大约有一万行的文本文件统计高频词 3.怎么在海量数据中找出重复次数最多的一个？ 4.判断数据是否在大量数据中 ",
  "wordCount" : "27151",
  "inLanguage": "en",
  "datePublished": "2023-11-25T00:31:00+08:00",
  "dateModified": "2023-11-25T00:31:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "Yu"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yurooc.github.io/blog/python%E5%9F%BA%E7%A1%80/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "YuBlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yurooc.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yurooc.github.io" accesskey="h" title="YuBlog (Alt + H)">YuBlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yurooc.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://yurooc.github.io/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://yurooc.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://yurooc.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/yurooc" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://yurooc.github.io">Home</a>&nbsp;»&nbsp;<a href="https://yurooc.github.io/blog/">Blogs</a></div>
    <h1 class="post-title">
      Python基础面经
    </h1>
    <div class="post-description">
      Python面经
    </div>
    <div class="post-meta"><span title='2023-11-25 00:31:00 +0800 CST'>November 25, 2023</span>&nbsp;·&nbsp;55 min&nbsp;·&nbsp;27151 words&nbsp;·&nbsp;Yu


      <div  class="meta-item">&nbsp·&nbsp
      <span id="busuanzi_container_page_pv">本文阅读量<span id="busuanzi_value_page_pv"></span>次</span>
    </div>
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#python%e5%9f%ba%e7%a1%80" aria-label="Python基础">Python基础</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#1python%e6%96%b0%e5%bc%8f%e7%b1%bb%e5%92%8c%e7%bb%8f%e5%85%b8%e7%b1%bb%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="1.python新式类和经典类的区别？">1.python新式类和经典类的区别？</a></li>
                    <li>
                        <a href="#2python%e4%b8%ad%e5%86%85%e7%bd%ae%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%9c%89%e5%87%a0%e7%a7%8d" aria-label="2.python中内置的数据结构有几种？">2.python中内置的数据结构有几种？</a></li>
                    <li>
                        <a href="#3python%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e8%af%b7%e5%86%99%e5%87%ba%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f" aria-label="3.python如何实现单例模式?请写出两种实现方式?">3.python如何实现单例模式?请写出两种实现方式?</a></li>
                    <li>
                        <a href="#4%e5%8f%af%e5%8f%98%e7%b1%bb%e5%9e%8b%e5%92%8c%e4%b8%8d%e5%8f%af%e5%8f%98%e7%b1%bb%e5%9e%8b" aria-label="4.可变类型和不可变类型">4.可变类型和不可变类型</a></li>
                    <li>
                        <a href="#5is%e5%92%8c%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="5.is和==有什么区别？">5.is和==有什么区别？</a></li>
                    <li>
                        <a href="#6python%e4%b8%ad%e5%8f%98%e9%87%8f%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%8f%98%e9%87%8f%e6%9f%a5%e6%89%be%e9%a1%ba%e5%ba%8f" aria-label="6.Python中变量的作用域？（变量查找顺序)">6.Python中变量的作用域？（变量查找顺序)</a></li>
                    <li>
                        <a href="#7super%e5%87%bd%e6%95%b0%e7%9a%84%e5%85%b7%e4%bd%93%e7%94%a8%e6%b3%95%e5%92%8c%e5%9c%ba%e6%99%af" aria-label="7.super函数的具体用法和场景">7.super函数的具体用法和场景</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#python%e9%ab%98%e7%ba%a7" aria-label="Python高级">Python高级</a><ul>
                            
                    <li>
                        <a href="#%e5%85%83%e7%b1%bb" aria-label="元类">元类</a><ul>
                            
                    <li>
                        <a href="#1python%e4%b8%ad%e7%b1%bb%e6%96%b9%e6%b3%95%e7%b1%bb%e5%ae%9e%e4%be%8b%e6%96%b9%e6%b3%95%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95%e6%9c%89%e4%bd%95%e5%8c%ba%e5%88%ab" aria-label="1.Python中类方法、类实例方法、静态方法有何区别？">1.Python中类方法、类实例方法、静态方法有何区别？</a></li>
                    <li>
                        <a href="#2%e4%bb%8b%e7%bb%8dcythonpypy-cpython-numba%e5%90%84%e6%9c%89%e4%bb%80%e4%b9%88%e7%bc%ba%e7%82%b9" aria-label="2.介绍Cython，Pypy Cpython Numba各有什么缺点">2.介绍Cython，Pypy Cpython Numba各有什么缺点</a></li>
                    <li>
                        <a href="#3%e8%af%b7%e6%8f%8f%e8%bf%b0%e6%8a%bd%e8%b1%a1%e7%b1%bb%e5%92%8c%e6%8e%a5%e5%8f%a3%e7%b1%bb%e7%9a%84%e5%8c%ba%e5%88%ab%e5%92%8c%e8%81%94%e7%b3%bb" aria-label="3.请描述抽象类和接口类的区别和联系">3.请描述抽象类和接口类的区别和联系</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%bb%80%e4%b9%88%e6%98%afpython%e4%b8%ad%e7%9a%84gil" aria-label="什么是Python中的GIL？">什么是Python中的GIL？</a></li>
                    <li>
                        <a href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e4%b8%8e%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6" aria-label="内存管理与垃圾回收机制">内存管理与垃圾回收机制</a><ul>
                            
                    <li>
                        <a href="#1%e5%93%aa%e4%ba%9b%e6%93%8d%e4%bd%9c%e4%bc%9a%e5%af%bc%e8%87%b4python%e5%86%85%e5%ad%98%e6%ba%a2%e5%87%ba%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86" aria-label="1.哪些操作会导致Python内存溢出，怎么处理？">1.哪些操作会导致Python内存溢出，怎么处理？</a></li>
                    <li>
                        <a href="#2%e5%85%b3%e4%ba%8epython%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e4%b8%8b%e5%88%97%e8%af%b4%e6%b3%95%e9%94%99%e8%af%af%e7%9a%84%e6%98%af--b" aria-label="2.关于Python内存管理,下列说法错误的是  B">2.关于Python内存管理,下列说法错误的是  B</a></li>
                    <li>
                        <a href="#3python%e7%9a%84%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%9c%ba%e5%88%b6%e5%8f%8a%e8%b0%83%e4%bc%98%e6%89%8b%e6%ae%b5" aria-label="3.Python的内存管理机制及调优手段？">3.Python的内存管理机制及调优手段？</a></li>
                    <li>
                        <a href="#4%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2%e6%98%af%e4%bb%80%e4%b9%88%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" aria-label="4.内存泄露是什么？如何避免？">4.内存泄露是什么？如何避免？</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%87%bd%e6%95%b0" aria-label="函数">函数</a><ul>
                            
                    <li>
                        <a href="#1%e7%ae%80%e8%bf%b0readreadlinereadlines%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="1.简述read、readline、readlines的区别？">1.简述read、readline、readlines的区别？</a></li>
                    <li>
                        <a href="#2%e4%bb%80%e4%b9%88%e6%98%afhash%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0" aria-label="2.什么是Hash（散列函数）？">2.什么是Hash（散列函数）？</a></li>
                    <li>
                        <a href="#3python%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e6%9c%ba%e5%88%b6" aria-label="3.python函数重载机制？">3.python函数重载机制？</a></li>
                    <li>
                        <a href="#4%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e5%8f%82%e6%95%b0%e7%9a%84%e4%bc%a0%e9%80%92%e6%96%b9%e5%bc%8f%e6%98%af%e5%80%bc%e4%bc%a0%e9%80%92%e8%bf%98%e6%98%af%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92" aria-label="4.函数调用参数的传递方式是值传递还是引用传递？">4.函数调用参数的传递方式是值传递还是引用传递？</a></li>
                    <li>
                        <a href="#5%e5%a6%82%e4%bd%95%e5%9c%a8function%e9%87%8c%e9%9d%a2%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f" aria-label="5.如何在function里面设置一个全局变量">5.如何在function里面设置一个全局变量</a></li>
                    <li>
                        <a href="#6%e5%af%b9%e7%bc%ba%e7%9c%81%e5%8f%82%e6%95%b0%e7%9a%84%e7%90%86%e8%a7%a3-" aria-label="6.对缺省参数的理解 ？">6.对缺省参数的理解 ？</a></li>
                    <li>
                        <a href="#7mysql%e6%80%8e%e4%b9%88%e9%99%90%e5%88%b6ip%e8%ae%bf%e9%97%ae" aria-label="7.Mysql怎么限制IP访问？">7.Mysql怎么限制IP访问？</a></li>
                    <li>
                        <a href="#8%e5%b8%a6%e5%8f%82%e6%95%b0%e7%9a%84%e8%a3%85%e9%a5%b0%e5%99%a8" aria-label="8.带参数的装饰器?">8.带参数的装饰器?</a></li>
                    <li>
                        <a href="#9%e4%b8%ba%e4%bb%80%e4%b9%88%e5%87%bd%e6%95%b0%e5%90%8d%e5%ad%97%e5%8f%af%e4%bb%a5%e5%bd%93%e5%81%9a%e5%8f%82%e6%95%b0%e7%94%a8" aria-label="9.为什么函数名字可以当做参数用?">9.为什么函数名字可以当做参数用?</a></li>
                    <li>
                        <a href="#10map%e5%87%bd%e6%95%b0%e5%92%8creduce%e5%87%bd%e6%95%b0" aria-label="10.map函数和reduce函数？">10.map函数和reduce函数？</a></li>
                    <li>
                        <a href="#11%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0%e5%a6%82%e4%bd%95%e9%80%9a%e4%bf%a1%e7%9a%84" aria-label="11.回调函数，如何通信的?">11.回调函数，如何通信的?</a></li>
                    <li>
                        <a href="#12python%e4%b8%bb%e8%a6%81%e7%9a%84%e5%86%85%e7%bd%ae%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b-print-dir-a--%e7%9a%84%e8%be%93%e5%87%ba" aria-label="12.Python主要的内置数据类型都有哪些？ print dir( ‘a ’) 的输出？">12.Python主要的内置数据类型都有哪些？ print dir( ‘a ’) 的输出？</a></li>
                    <li>
                        <a href="#13hasattr-getattr-setattr-%e5%87%bd%e6%95%b0%e4%bd%bf%e7%94%a8%e8%af%a6%e8%a7%a3" aria-label="13.hasattr() getattr() setattr() 函数使用详解？">13.hasattr() getattr() setattr() 函数使用详解？</a></li>
                    <li>
                        <a href="#14%e4%bb%80%e4%b9%88%e6%98%aflambda%e5%87%bd%e6%95%b0-%e6%9c%89%e4%bb%80%e4%b9%88%e5%a5%bd%e5%a4%84" aria-label="14.什么是lambda函数？ 有什么好处？">14.什么是lambda函数？ 有什么好处？</a></li>
                    <li>
                        <a href="#15%e9%80%92%e5%bd%92%e5%87%bd%e6%95%b0%e5%81%9c%e6%ad%a2%e7%9a%84%e6%9d%a1%e4%bb%b6" aria-label="15.递归函数停止的条件？">15.递归函数停止的条件？</a></li>
                    <li>
                        <a href="#16%e4%bb%80%e4%b9%88%e6%98%aflambda%e5%87%bd%e6%95%b0%e5%ae%83%e6%9c%89%e4%bb%80%e4%b9%88%e5%a5%bd%e5%a4%84%e5%86%99%e4%b8%80%e4%b8%aa%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0%e6%b1%82%e4%b8%a4%e4%b8%aa%e6%95%b0%e7%9a%84%e5%92%8c" aria-label="16.什么是lambda函数？它有什么好处？写一个匿名函数求两个数的和">16.什么是lambda函数？它有什么好处？写一个匿名函数求两个数的和</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" aria-label="设计模式">设计模式</a><ul>
                            
                    <li>
                        <a href="#1%e5%af%b9%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e7%9a%84%e7%90%86%e8%a7%a3%e7%ae%80%e8%bf%b0%e4%bd%a0%e4%ba%86%e8%a7%a3%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" aria-label="1.对设计模式的理解，简述你了解的设计模式？">1.对设计模式的理解，简述你了解的设计模式？</a></li>
                    <li>
                        <a href="#2%e8%af%b7%e6%89%8b%e5%86%99%e4%b8%80%e4%b8%aa%e5%8d%95%e4%be%8b" aria-label="2.请手写一个单例">2.请手写一个单例</a></li>
                    <li>
                        <a href="#3%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e6%9c%89%e9%82%a3%e4%ba%9b" aria-label="3.单例模式的应用场景有那些？">3.单例模式的应用场景有那些？</a></li>
                    <li>
                        <a href="#4%e5%af%b9%e8%a3%85%e9%a5%b0%e5%99%a8%e7%9a%84%e7%90%86%e8%a7%a3%e5%b9%b6%e5%86%99%e5%87%ba%e4%b8%80%e4%b8%aa%e8%ae%a1%e6%97%b6%e5%99%a8%e8%ae%b0%e5%bd%95%e6%96%b9%e6%b3%95%e6%89%a7%e8%a1%8c%e6%80%a7%e8%83%bd%e7%9a%84%e8%a3%85%e9%a5%b0%e5%99%a8" aria-label="4.对装饰器的理解，并写出一个计时器记录方法执行性能的装饰器？">4.对装饰器的理解，并写出一个计时器记录方法执行性能的装饰器？</a></li>
                    <li>
                        <a href="#5%e8%a7%a3%e9%87%8a%e4%bb%a5%e4%b8%8b%e4%bb%80%e4%b9%88%e6%98%af%e9%97%ad%e5%8c%85" aria-label="5.解释以下什么是闭包？">5.解释以下什么是闭包？</a></li>
                    <li>
                        <a href="#6%e5%87%bd%e6%95%b0%e8%a3%85%e9%a5%b0%e5%99%a8%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8" aria-label="6.函数装饰器有什么作用？">6.函数装饰器有什么作用？</a></li>
                    <li>
                        <a href="#7%e7%94%9f%e6%88%90%e5%99%a8%e8%bf%ad%e4%bb%a3%e5%99%a8%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="7.生成器，迭代器的区别？">7.生成器，迭代器的区别？</a></li>
                    <li>
                        <a href="#8python%e4%b8%adyield%e7%9a%84%e7%94%a8%e6%b3%95" aria-label="8.Python中yield的用法?">8.Python中yield的用法?</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1" aria-label="面向对象">面向对象</a><ul>
                            
                    <li>
                        <a href="#1python%e4%b8%ad%e7%9a%84%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1%e5%92%8c%e4%b8%8d%e5%8f%af%e5%8f%98%e5%af%b9%e8%b1%a1" aria-label="1.Python中的可变对象和不可变对象？">1.Python中的可变对象和不可变对象？</a></li>
                    <li>
                        <a href="#2python%e7%9a%84%e9%ad%94%e6%b3%95%e6%96%b9%e6%b3%95" aria-label="2.Python的魔法方法">2.Python的魔法方法</a></li>
                    <li>
                        <a href="#3%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%ad%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e5%8f%aa%e8%af%bb%e5%b1%9e%e6%80%a7" aria-label="3.面向对象中怎么实现只读属性?">3.面向对象中怎么实现只读属性?</a></li>
                    <li>
                        <a href="#4%e8%b0%88%e8%b0%88%e4%bd%a0%e5%af%b9%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%90%86%e8%a7%a3" aria-label="4.谈谈你对面向对象的理解？">4.谈谈你对面向对象的理解？</a></li>
                    <li>
                        <a href="#5python%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9f%a5%e6%89%be%e5%92%8c%e6%9b%bf%e6%8d%a2" aria-label="5.Python字符串查找和替换？">5.Python字符串查找和替换？</a></li>
                    <li>
                        <a href="#6%e7%94%a8python%e5%8c%b9%e9%85%8dhtml-tag%e7%9a%84%e6%97%b6%e5%80%99-%e5%92%8c--%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="6.用Python匹配HTML tag的时候，&amp;lt;.&amp;gt; 和 &amp;lt;.?&amp;gt; 有什么区别">6.用Python匹配HTML tag的时候，&lt;.<em>&gt; 和 &lt;.</em>?&gt; 有什么区别</a></li>
                    <li>
                        <a href="#7%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e8%b4%aa%e5%a9%aa%e4%b8%8e%e9%9d%9e%e8%b4%aa%e5%a9%aa%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="7.正则表达式贪婪与非贪婪模式的区别？">7.正则表达式贪婪与非贪婪模式的区别？</a></li>
                    <li>
                        <a href="#8%e6%80%8e%e4%b9%88%e8%bf%87%e6%bb%a4%e8%af%84%e8%ae%ba%e4%b8%ad%e7%9a%84%e8%a1%a8%e6%83%85" aria-label="8.怎么过滤评论中的表情？">8.怎么过滤评论中的表情？</a></li>
                    <li>
                        <a href="#9%e7%ae%80%e8%bf%b0python%e9%87%8c%e9%9d%a2search%e5%92%8cmatch%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="9.简述Python里面search和match的区别">9.简述Python里面search和match的区别</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b" aria-label="系统编程">系统编程</a><ul>
                            
                    <li>
                        <a href="#1%e8%bf%9b%e7%a8%8b%e6%80%bb%e7%bb%93" aria-label="1.进程总结">1.进程总结</a></li>
                    <li>
                        <a href="#2%e8%b0%88%e8%b0%88%e4%bd%a0%e5%af%b9%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%bb%a5%e5%8f%8a%e5%8d%8f%e7%a8%8b%e7%9a%84%e7%90%86%e8%a7%a3%e9%a1%b9%e7%9b%ae%e6%98%af%e5%90%a6%e7%94%a8" aria-label="2.谈谈你对多进程，多线程，以及协程的理解，项目是否用？">2.谈谈你对多进程，多线程，以及协程的理解，项目是否用？</a></li>
                    <li>
                        <a href="#3python%e5%bc%82%e6%ad%a5%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e6%9c%89%e9%82%a3%e4%ba%9b" aria-label="3.Python异步使用场景有那些？">3.Python异步使用场景有那些？</a></li>
                    <li>
                        <a href="#4%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%85%b1%e5%90%8c%e6%93%8d%e4%bd%9c%e5%90%8c%e4%b8%80%e4%b8%aa%e6%95%b0%e6%8d%ae%e4%ba%92%e6%96%a5%e9%94%81%e5%90%8c%e6%ad%a5" aria-label="4.多线程共同操作同一个数据互斥锁同步？">4.多线程共同操作同一个数据互斥锁同步？</a></li>
                    <li>
                        <a href="#5%e4%bb%80%e4%b9%88%e6%98%af%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%ab%9e%e4%ba%89" aria-label="5.什么是多线程竞争？">5.什么是多线程竞争？</a></li>
                    <li>
                        <a href="#6%e8%af%b7%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8bpython%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5" aria-label="6.请介绍一下Python的线程同步？">6.请介绍一下Python的线程同步？</a></li>
                    <li>
                        <a href="#7%e8%a7%a3%e9%87%8a%e4%bb%a5%e4%b8%8b%e4%bb%80%e4%b9%88%e6%98%af%e9%94%81%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e9%94%81" aria-label="7.解释以下什么是锁，有哪几种锁？">7.解释以下什么是锁，有哪几种锁？</a></li>
                    <li>
                        <a href="#8%e4%bb%80%e4%b9%88%e6%98%af%e6%ad%bb%e9%94%81" aria-label="8.什么是死锁？">8.什么是死锁？</a></li>
                    <li>
                        <a href="#9%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%ba%a4%e4%ba%92%e8%ae%bf%e9%97%ae%e6%95%b0%e6%8d%ae%e5%a6%82%e6%9e%9c%e8%ae%bf%e9%97%ae%e5%88%b0%e4%ba%86%e5%b0%b1%e4%b8%8d%e8%ae%bf%e9%97%ae%e4%ba%86" aria-label="9.多线程交互访问数据，如果访问到了就不访问了？">9.多线程交互访问数据，如果访问到了就不访问了？</a></li>
                    <li>
                        <a href="#10%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%92%e6%96%a5%e9%94%81" aria-label="10.什么是线程安全，什么是互斥锁？">10.什么是线程安全，什么是互斥锁？</a></li>
                    <li>
                        <a href="#11%e8%af%b4%e8%af%b4%e4%b8%8b%e9%9d%a2%e5%87%a0%e4%b8%aa%e6%a6%82%e5%bf%b5%e5%90%8c%e6%ad%a5%e5%bc%82%e6%ad%a5%e9%98%bb%e5%a1%9e%e9%9d%9e%e9%98%bb%e5%a1%9e" aria-label="11.说说下面几个概念：同步，异步，阻塞，非阻塞？">11.说说下面几个概念：同步，异步，阻塞，非阻塞？</a></li>
                    <li>
                        <a href="#12%e4%bb%80%e4%b9%88%e6%98%af%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e5%92%8c%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e6%80%8e%e4%b9%88%e9%81%bf%e5%85%8d%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b" aria-label="12.什么是僵尸进程和孤儿进程？怎么避免僵尸进程？">12.什么是僵尸进程和孤儿进程？怎么避免僵尸进程？</a></li>
                    <li>
                        <a href="#13python%e4%b8%ad%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="13.python中进程与线程的使用场景？">13.python中进程与线程的使用场景？</a></li>
                    <li>
                        <a href="#14%e7%ba%bf%e7%a8%8b%e6%98%af%e5%b9%b6%e5%8f%91%e8%bf%98%e6%98%af%e5%b9%b6%e8%a1%8c%e8%bf%9b%e7%a8%8b%e6%98%af%e5%b9%b6%e5%8f%91%e8%bf%98%e6%98%af%e5%b9%b6%e8%a1%8c" aria-label="14.线程是并发还是并行，进程是并发还是并行？">14.线程是并发还是并行，进程是并发还是并行？</a></li>
                    <li>
                        <a href="#15%e5%b9%b6%e8%a1%8cparallel%e5%92%8c%e5%b9%b6%e5%8f%91concurrency" aria-label="15.并行(parallel)和并发（concurrency)?">15.并行(parallel)和并发（concurrency)?</a></li>
                    <li>
                        <a href="#16io%e5%af%86%e9%9b%86%e5%9e%8b%e5%92%8ccpu%e5%af%86%e9%9b%86%e5%9e%8b%e5%8c%ba%e5%88%ab" aria-label="16.IO密集型和CPU密集型区别？">16.IO密集型和CPU密集型区别？</a></li>
                    <li>
                        <a href="#17python-asyncio%e7%9a%84%e5%8e%9f%e7%90%86" aria-label="17.python asyncio的原理？">17.python asyncio的原理？</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8b" aria-label="网络编程">网络编程</a><ul>
                            
                    <li>
                        <a href="#1%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e5%bc%ba%e8%a1%8c%e5%85%b3%e9%97%ad%e5%ae%a2%e6%88%b7%e7%ab%af%e5%92%8c%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bf%9e%e6%8e%a5" aria-label="1.怎么实现强行关闭客户端和服务器之间的连接?">1.怎么实现强行关闭客户端和服务器之间的连接?</a></li>
                    <li>
                        <a href="#2%e7%ae%80%e8%bf%b0tcp%e5%92%8cudp%e7%9a%84%e5%8c%ba%e5%88%ab%e4%bb%a5%e5%8f%8a%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="2.简述TCP和UDP的区别以及优缺点?">2.简述TCP和UDP的区别以及优缺点?</a></li>
                    <li>
                        <a href="#3%e7%ae%80%e8%bf%b0%e6%b5%8f%e8%a7%88%e5%99%a8%e9%80%9a%e8%bf%87wsgi%e8%af%b7%e6%b1%82%e5%8a%a8%e6%80%81%e8%b5%84%e6%ba%90%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="3.简述浏览器通过WSGI请求动态资源的过程?">3.简述浏览器通过WSGI请求动态资源的过程?</a></li>
                    <li>
                        <a href="#4%e6%8f%8f%e8%bf%b0%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e8%ae%bf%e9%97%aewwwbaiducom%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="4.描述用浏览器访问www.baidu.com的过程">4.描述用浏览器访问www.baidu.com的过程</a></li>
                    <li>
                        <a href="#5post%e5%92%8cget%e8%af%b7%e6%b1%82%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="5.Post和Get请求的区别?">5.Post和Get请求的区别?</a></li>
                    <li>
                        <a href="#6cookie-%e5%92%8csession-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="6.cookie 和session 的区别？">6.cookie 和session 的区别？</a></li>
                    <li>
                        <a href="#7%e5%88%97%e5%87%ba%e4%bd%a0%e7%9f%a5%e9%81%93%e7%9a%84http%e5%8d%8f%e8%ae%ae%e7%9a%84%e7%8a%b6%e6%80%81%e7%a0%81%e8%af%b4%e5%87%ba%e8%a1%a8%e7%a4%ba%e4%bb%80%e4%b9%88%e6%84%8f%e6%80%9d" aria-label="7.列出你知道的HTTP协议的状态码，说出表示什么意思？">7.列出你知道的HTTP协议的状态码，说出表示什么意思？</a></li>
                    <li>
                        <a href="#8%e8%af%b7%e7%ae%80%e5%8d%95%e8%af%b4%e4%b8%80%e4%b8%8b%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%92%8c%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="8.请简单说一下三次握手和四次挥手？">8.请简单说一下三次握手和四次挥手？</a></li>
                    <li>
                        <a href="#9%e8%af%b4%e4%b8%80%e4%b8%8b%e4%bb%80%e4%b9%88%e6%98%aftcp%e7%9a%842msl" aria-label="9.说一下什么是tcp的2MSL？">9.说一下什么是tcp的2MSL？</a></li>
                    <li>
                        <a href="#10%e4%b8%ba%e4%bb%80%e4%b9%88%e5%ae%a2%e6%88%b7%e7%ab%af%e5%9c%a8time-wait%e7%8a%b6%e6%80%81%e5%bf%85%e9%a1%bb%e7%ad%89%e5%be%852msl%e7%9a%84%e6%97%b6%e9%97%b4" aria-label="10.为什么客户端在TIME-WAIT状态必须等待2MSL的时间？">10.为什么客户端在TIME-WAIT状态必须等待2MSL的时间？</a></li>
                    <li>
                        <a href="#11%e8%af%b4%e8%af%b4http%e5%92%8chttps%e5%8c%ba%e5%88%ab" aria-label="11.说说HTTP和HTTPS区别？">11.说说HTTP和HTTPS区别？</a></li>
                    <li>
                        <a href="#12%e8%b0%88%e4%b8%80%e4%b8%8bhttp%e5%8d%8f%e8%ae%ae%e4%bb%a5%e5%8f%8a%e5%8d%8f%e8%ae%ae%e5%a4%b4%e9%83%a8%e4%b8%ad%e8%a1%a8%e7%a4%ba%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ad%97%e6%ae%b5" aria-label="12.谈一下HTTP协议以及协议头部中表示数据类型的字段？">12.谈一下HTTP协议以及协议头部中表示数据类型的字段？</a></li>
                    <li>
                        <a href="#13http%e8%af%b7%e6%b1%82%e6%96%b9%e6%b3%95%e9%83%bd%e6%9c%89%e4%bb%80%e4%b9%88" aria-label="13.HTTP请求方法都有什么？">13.HTTP请求方法都有什么？</a></li>
                    <li>
                        <a href="#14%e4%bd%bf%e7%94%a8socket%e5%a5%97%e6%8e%a5%e5%ad%97%e9%9c%80%e8%a6%81%e4%bc%a0%e5%85%a5%e5%93%aa%e4%ba%9b%e5%8f%82%e6%95%b0-" aria-label="14.使用Socket套接字需要传入哪些参数 ？">14.使用Socket套接字需要传入哪些参数 ？</a></li>
                    <li>
                        <a href="#15http%e5%b8%b8%e8%a7%81%e8%af%b7%e6%b1%82%e5%a4%b4" aria-label="15.HTTP常见请求头？">15.HTTP常见请求头？</a></li>
                    <li>
                        <a href="#16%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b" aria-label="16.七层模型？">16.七层模型？</a></li>
                    <li>
                        <a href="#17url%e7%9a%84%e5%bd%a2%e5%bc%8f" aria-label="17.url的形式？">17.url的形式？</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#web" aria-label="Web">Web</a><ul>
                            
                    <li>
                        <a href="#flask" aria-label="Flask">Flask</a><ul>
                            
                    <li>
                        <a href="#1%e5%af%b9flask%e8%93%9d%e5%9b%beblueprint%e7%9a%84%e7%90%86%e8%a7%a3" aria-label="1.对Flask蓝图(Blueprint)的理解？">1.对Flask蓝图(Blueprint)的理解？</a></li>
                    <li>
                        <a href="#2flask-%e5%92%8c-django-%e8%b7%af%e7%94%b1%e6%98%a0%e5%b0%84%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="2.Flask 和 Django 路由映射的区别？">2.Flask 和 Django 路由映射的区别？</a></li></ul>
                    </li>
                    <li>
                        <a href="#django" aria-label="Django">Django</a><ul>
                            
                    <li>
                        <a href="#1%e4%bb%80%e4%b9%88%e6%98%afwsgiuwsgiuwsgi" aria-label="1.什么是wsgi,uwsgi,uWSGI?">1.什么是wsgi,uwsgi,uWSGI?</a></li>
                    <li>
                        <a href="#2djangoflasktornado%e7%9a%84%e5%af%b9%e6%af%94" aria-label="2.Django、Flask、Tornado的对比？">2.Django、Flask、Tornado的对比？</a></li>
                    <li>
                        <a href="#3cors-%e5%92%8c-csrf%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="3.CORS 和 CSRF的区别？">3.CORS 和 CSRF的区别？</a></li>
                    <li>
                        <a href="#4sessioncookiejwt%e7%9a%84%e7%90%86%e8%a7%a3" aria-label="4.Session,Cookie,JWT的理解">4.Session,Cookie,JWT的理解</a></li>
                    <li>
                        <a href="#5%e7%ae%80%e8%bf%b0django%e8%af%b7%e6%b1%82%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" aria-label="5.简述Django请求生命周期">5.简述Django请求生命周期</a></li>
                    <li>
                        <a href="#6%e7%94%a8%e7%9a%84restframework%e5%ae%8c%e6%88%90api%e5%8f%91%e9%80%81%e6%97%b6%e9%97%b4%e6%97%b6%e5%8c%ba" aria-label="6.用的restframework完成api发送时间时区">6.用的restframework完成api发送时间时区</a></li>
                    <li>
                        <a href="#7nginxtomcatapach%e5%88%b0%e9%83%bd%e6%98%af%e4%bb%80%e4%b9%88" aria-label="7.nginx,tomcat,apach到都是什么？">7.nginx,tomcat,apach到都是什么？</a></li>
                    <li>
                        <a href="#8%e8%af%b7%e7%bb%99%e5%87%ba%e4%bd%a0%e7%86%9f%e6%82%89%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e5%ba%93%e8%8c%83%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8" aria-label="8.请给出你熟悉关系数据库范式有哪些，有什么作用？">8.请给出你熟悉关系数据库范式有哪些，有什么作用？</a></li>
                    <li>
                        <a href="#9%e7%ae%80%e8%bf%b0qq%e7%99%bb%e9%99%86%e8%bf%87%e7%a8%8b" aria-label="9.简述QQ登陆过程">9.简述QQ登陆过程</a></li>
                    <li>
                        <a href="#10post-%e5%92%8c-get%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="10.post 和 get的区别?">10.post 和 get的区别?</a></li>
                    <li>
                        <a href="#11%e9%a1%b9%e7%9b%ae%e4%b8%ad%e6%97%a5%e5%bf%97%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="11.项目中日志的作用">11.项目中日志的作用</a></li>
                    <li>
                        <a href="#12django%e4%b8%ad%e9%97%b4%e4%bb%b6%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="12.django中间件的使用？">12.django中间件的使用？</a></li>
                    <li>
                        <a href="#13%e8%b0%88%e4%b8%80%e4%b8%8b%e4%bd%a0%e5%af%b9uwsgi%e5%92%8cnginx%e7%9a%84%e7%90%86%e8%a7%a3" aria-label="13.谈一下你对uWSGI和nginx的理解？">13.谈一下你对uWSGI和nginx的理解？</a></li>
                    <li>
                        <a href="#14python%e4%b8%ad%e4%b8%89%e5%a4%a7%e6%a1%86%e6%9e%b6%e5%90%84%e8%87%aa%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="14.Python中三大框架各自的应用场景？">14.Python中三大框架各自的应用场景？</a></li>
                    <li>
                        <a href="#15django%e4%b8%ad%e5%93%aa%e9%87%8c%e7%94%a8%e5%88%b0%e4%ba%86%e7%ba%bf%e7%a8%8b%e5%93%aa%e9%87%8c%e7%94%a8%e5%88%b0%e4%ba%86%e5%8d%8f%e7%a8%8b%e5%93%aa%e9%87%8c%e7%94%a8%e5%88%b0%e4%ba%86%e8%bf%9b%e7%a8%8b" aria-label="15.Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？">15.Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？</a></li>
                    <li>
                        <a href="#16%e6%9c%89%e7%94%a8%e8%bf%87django-rest-framework%e5%90%97" aria-label="16.有用过Django REST framework吗？">16.有用过Django REST framework吗？</a></li>
                    <li>
                        <a href="#17%e5%af%b9cookies%e4%b8%8esession%e7%9a%84%e4%ba%86%e8%a7%a3%e4%bb%96%e4%bb%ac%e8%83%bd%e5%8d%95%e7%8b%ac%e7%94%a8%e5%90%97" aria-label="17.对cookies与session的了解？他们能单独用吗？">17.对cookies与session的了解？他们能单独用吗？</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%88%ac%e8%99%ab" aria-label="爬虫">爬虫</a><ul>
                            
                    <li>
                        <a href="#1%e8%af%95%e5%88%97%e5%87%ba%e8%87%b3%e5%b0%91%e4%b8%89%e7%a7%8d%e7%9b%ae%e5%89%8d%e6%b5%81%e8%a1%8c%e7%9a%84%e5%a4%a7%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="1.试列出至少三种目前流行的大型数据库">1.试列出至少三种目前流行的大型数据库</a></li>
                    <li>
                        <a href="#2%e5%88%97%e4%b8%be%e6%82%a8%e4%bd%bf%e7%94%a8%e8%bf%87%e7%9a%84python%e7%bd%91%e7%bb%9c%e7%88%ac%e8%99%ab%e6%89%80%e7%94%a8%e5%88%b0%e7%9a%84%e7%bd%91%e7%bb%9c%e6%95%b0%e6%8d%ae%e5%8c%85" aria-label="2.列举您使用过的Python网络爬虫所用到的网络数据包?">2.列举您使用过的Python网络爬虫所用到的网络数据包?</a></li>
                    <li>
                        <a href="#3%e7%88%ac%e5%8f%96%e6%95%b0%e6%8d%ae%e5%90%8e%e4%bd%bf%e7%94%a8%e5%93%aa%e4%b8%aa%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae%e7%9a%84%e4%b8%ba%e4%bb%80%e4%b9%88" aria-label="3.爬取数据后使用哪个数据库存储数据的，为什么？">3.爬取数据后使用哪个数据库存储数据的，为什么？</a></li>
                    <li>
                        <a href="#4%e4%bd%a0%e7%94%a8%e8%bf%87%e7%9a%84%e7%88%ac%e8%99%ab%e6%a1%86%e6%9e%b6%e6%88%96%e8%80%85%e6%a8%a1%e5%9d%97%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="4.你用过的爬虫框架或者模块有哪些？优缺点？">4.你用过的爬虫框架或者模块有哪些？优缺点？</a></li>
                    <li>
                        <a href="#5%e5%86%99%e7%88%ac%e8%99%ab%e6%98%af%e7%94%a8%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%a5%bd%e8%bf%98%e6%98%af%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%a5%bd" aria-label="5.写爬虫是用多进程好？还是多线程好？">5.写爬虫是用多进程好？还是多线程好？</a></li>
                    <li>
                        <a href="#6%e5%b8%b8%e8%a7%81%e7%9a%84%e5%8f%8d%e7%88%ac%e8%99%ab%e5%92%8c%e5%ba%94%e5%af%b9%e6%96%b9%e6%b3%95" aria-label="6.常见的反爬虫和应对方法？">6.常见的反爬虫和应对方法？</a></li>
                    <li>
                        <a href="#7%e8%a7%a3%e6%9e%90%e7%bd%91%e9%a1%b5%e7%9a%84%e8%a7%a3%e6%9e%90%e5%99%a8%e4%bd%bf%e7%94%a8%e6%9c%80%e5%a4%9a%e7%9a%84%e6%98%af%e5%93%aa%e5%87%a0%e4%b8%aa" aria-label="7.解析网页的解析器使用最多的是哪几个?">7.解析网页的解析器使用最多的是哪几个?</a></li>
                    <li>
                        <a href="#8%e9%9c%80%e8%a6%81%e7%99%bb%e5%bd%95%e7%9a%84%e7%bd%91%e9%a1%b5%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e5%90%8c%e6%97%b6%e9%99%90%e5%88%b6ipcookiesession" aria-label="8.需要登录的网页，如何解决同时限制ip，cookie,session">8.需要登录的网页，如何解决同时限制ip，cookie,session</a></li>
                    <li>
                        <a href="#9%e9%aa%8c%e8%af%81%e7%a0%81%e7%9a%84%e8%a7%a3%e5%86%b3" aria-label="9.验证码的解决?">9.验证码的解决?</a></li>
                    <li>
                        <a href="#10%e4%bd%bf%e7%94%a8%e6%9c%80%e5%a4%9a%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e5%af%b9%e4%bb%96%e4%bb%ac%e7%9a%84%e7%90%86%e8%a7%a3" aria-label="10.使用最多的数据库，对他们的理解？">10.使用最多的数据库，对他们的理解？</a></li>
                    <li>
                        <a href="#11%e7%bc%96%e5%86%99%e8%bf%87%e5%93%aa%e4%ba%9b%e7%88%ac%e8%99%ab%e4%b8%ad%e9%97%b4%e4%bb%b6" aria-label="11.编写过哪些爬虫中间件？">11.编写过哪些爬虫中间件？</a></li>
                    <li>
                        <a href="#12%e6%9e%81%e9%aa%8c%e6%bb%91%e5%8a%a8%e9%aa%8c%e8%af%81%e7%a0%81%e5%a6%82%e4%bd%95%e7%a0%b4%e8%a7%a3" aria-label="12.“极验”滑动验证码如何破解？">12.“极验”滑动验证码如何破解？</a></li>
                    <li>
                        <a href="#13%e7%88%ac%e8%99%ab%e5%a4%9a%e4%b9%85%e7%88%ac%e4%b8%80%e6%ac%a1%e7%88%ac%e4%b8%8b%e6%9d%a5%e7%9a%84%e6%95%b0%e6%8d%ae%e6%98%af%e6%80%8e%e4%b9%88%e5%ad%98%e5%82%a8" aria-label="13.爬虫多久爬一次，爬下来的数据是怎么存储？">13.爬虫多久爬一次，爬下来的数据是怎么存储？</a></li>
                    <li>
                        <a href="#14cookie%e8%bf%87%e6%9c%9f%e7%9a%84%e5%a4%84%e7%90%86%e9%97%ae%e9%a2%98" aria-label="14.cookie过期的处理问题？">14.cookie过期的处理问题？</a></li>
                    <li>
                        <a href="#15%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd%e5%8f%88%e5%af%b9%e5%8f%8a%e6%97%b6%e6%80%a7%e8%a6%81%e6%b1%82%e5%be%88%e9%ab%98%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86" aria-label="15.动态加载又对及时性要求很高怎么处理？">15.动态加载又对及时性要求很高怎么处理？</a></li>
                    <li>
                        <a href="#16https%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9" aria-label="16.HTTPS有什么优点和缺点？">16.HTTPS有什么优点和缺点？</a></li>
                    <li>
                        <a href="#17https%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%ae%89%e5%85%a8%e4%bc%a0%e8%be%93%e6%95%b0%e6%8d%ae%e7%9a%84" aria-label="17.HTTPS是如何实现安全传输数据的？">17.HTTPS是如何实现安全传输数据的？</a></li>
                    <li>
                        <a href="#18ttlmslrtt%e5%90%84%e6%98%af%e4%bb%80%e4%b9%88" aria-label="18.TTL，MSL，RTT各是什么？">18.TTL，MSL，RTT各是什么？</a></li>
                    <li>
                        <a href="#19%e8%b0%88%e4%b8%80%e8%b0%88%e4%bd%a0%e5%af%b9selenium%e5%92%8cphantomjs%e4%ba%86%e8%a7%a3" aria-label="19.谈一谈你对Selenium和PhantomJS了解">19.谈一谈你对Selenium和PhantomJS了解</a></li>
                    <li>
                        <a href="#20%e5%b9%b3%e5%b8%b8%e6%80%8e%e4%b9%88%e4%bd%bf%e7%94%a8%e4%bb%a3%e7%90%86%e7%9a%84-" aria-label="20.平常怎么使用代理的 ？">20.平常怎么使用代理的 ？</a></li>
                    <li>
                        <a href="#21%e5%ad%98%e6%94%be%e5%9c%a8%e6%95%b0%e6%8d%ae%e5%ba%93redismysql%e7%ad%89" aria-label="21.存放在数据库(redis、mysql等)。">21.存放在数据库(redis、mysql等)。</a></li>
                    <li>
                        <a href="#22%e6%80%8e%e4%b9%88%e7%9b%91%e6%8e%a7%e7%88%ac%e8%99%ab%e7%9a%84%e7%8a%b6%e6%80%81" aria-label="22.怎么监控爬虫的状态?">22.怎么监控爬虫的状态?</a></li>
                    <li>
                        <a href="#23%e6%8f%8f%e8%bf%b0%e4%b8%8bscrapy%e6%a1%86%e6%9e%b6%e8%bf%90%e8%a1%8c%e7%9a%84%e6%9c%ba%e5%88%b6" aria-label="23.描述下scrapy框架运行的机制？">23.描述下scrapy框架运行的机制？</a></li>
                    <li>
                        <a href="#24%e8%b0%88%e8%b0%88%e4%bd%a0%e5%af%b9scrapy%e7%9a%84%e7%90%86%e8%a7%a3" aria-label="24.谈谈你对Scrapy的理解？">24.谈谈你对Scrapy的理解？</a></li>
                    <li>
                        <a href="#25%e6%80%8e%e4%b9%88%e6%a0%b7%e8%ae%a9-scrapy-%e6%a1%86%e6%9e%b6%e5%8f%91%e9%80%81%e4%b8%80%e4%b8%aa-post-%e8%af%b7%e6%b1%82%e5%85%b7%e4%bd%93%e5%86%99%e5%87%ba%e6%9d%a5" aria-label="25.怎么样让 scrapy 框架发送一个 post 请求（具体写出来）">25.怎么样让 scrapy 框架发送一个 post 请求（具体写出来）</a></li>
                    <li>
                        <a href="#26%e6%80%8e%e4%b9%88%e7%9b%91%e6%8e%a7%e7%88%ac%e8%99%ab%e7%9a%84%e7%8a%b6%e6%80%81-" aria-label="26.怎么监控爬虫的状态 ？">26.怎么监控爬虫的状态 ？</a></li>
                    <li>
                        <a href="#27%e6%80%8e%e4%b9%88%e5%88%a4%e6%96%ad%e7%bd%91%e7%ab%99%e6%98%af%e5%90%a6%e6%9b%b4%e6%96%b0" aria-label="27.怎么判断网站是否更新？">27.怎么判断网站是否更新？</a></li>
                    <li>
                        <a href="#28%e5%9b%be%e7%89%87%e8%a7%86%e9%a2%91%e7%88%ac%e5%8f%96%e6%80%8e%e4%b9%88%e7%bb%95%e8%bf%87%e9%98%b2%e7%9b%97%e8%bf%9e%e6%8e%a5" aria-label="28.图片、视频爬取怎么绕过防盗连接">28.图片、视频爬取怎么绕过防盗连接</a></li>
                    <li>
                        <a href="#29%e4%bd%a0%e7%88%ac%e5%87%ba%e6%9d%a5%e7%9a%84%e6%95%b0%e6%8d%ae%e9%87%8f%e5%a4%a7%e6%a6%82%e6%9c%89%e5%a4%9a%e5%a4%a7%e5%a4%a7%e6%a6%82%e5%a4%9a%e9%95%bf%e6%97%b6%e9%97%b4%e7%88%ac%e4%b8%80%e6%ac%a1" aria-label="29.你爬出来的数据量大概有多大？大概多长时间爬一次？">29.你爬出来的数据量大概有多大？大概多长时间爬一次？</a></li>
                    <li>
                        <a href="#30%e7%94%a8%e4%bb%80%e4%b9%88%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ad%98%e7%88%ac%e4%b8%8b%e6%9d%a5%e7%9a%84%e6%95%b0%e6%8d%ae%e9%83%a8%e7%bd%b2%e6%98%af%e4%bd%a0%e5%81%9a%e7%9a%84%e5%90%97%e6%80%8e%e4%b9%88%e9%83%a8%e7%bd%b2" aria-label="30.用什么数据库存爬下来的数据？部署是你做的吗？怎么部署？">30.用什么数据库存爬下来的数据？部署是你做的吗？怎么部署？</a></li>
                    <li>
                        <a href="#31%e5%a2%9e%e9%87%8f%e7%88%ac%e5%8f%96" aria-label="31.增量爬取">31.增量爬取</a></li>
                    <li>
                        <a href="#32%e7%88%ac%e5%8f%96%e4%b8%8b%e6%9d%a5%e7%9a%84%e6%95%b0%e6%8d%ae%e5%a6%82%e4%bd%95%e5%8e%bb%e9%87%8d%e8%af%b4%e4%b8%80%e4%b8%8bscrapy%e7%9a%84%e5%85%b7%e4%bd%93%e7%9a%84%e7%ae%97%e6%b3%95%e4%be%9d%e6%8d%ae" aria-label="32.爬取下来的数据如何去重，说一下scrapy的具体的算法依据。">32.爬取下来的数据如何去重，说一下scrapy的具体的算法依据。</a></li>
                    <li>
                        <a href="#33scrapy%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="33.Scrapy的优缺点?">33.Scrapy的优缺点?</a></li>
                    <li>
                        <a href="#34%e6%80%8e%e4%b9%88%e8%ae%be%e7%bd%ae%e7%88%ac%e5%8f%96%e6%b7%b1%e5%ba%a6" aria-label="34.怎么设置爬取深度？">34.怎么设置爬取深度？</a></li>
                    <li>
                        <a href="#35scrapy%e5%92%8cscrapy-redis%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9redis%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="35.scrapy和scrapy-redis有什么区别？为什么选择redis数据库？">35.scrapy和scrapy-redis有什么区别？为什么选择redis数据库？</a></li>
                    <li>
                        <a href="#36%e5%88%86%e5%b8%83%e5%bc%8f%e7%88%ac%e8%99%ab%e4%b8%bb%e8%a6%81%e8%a7%a3%e5%86%b3%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98" aria-label="36.分布式爬虫主要解决什么问题？">36.分布式爬虫主要解决什么问题？</a></li>
                    <li>
                        <a href="#37%e4%bb%80%e4%b9%88%e6%98%af%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8" aria-label="37.什么是分布式存储？">37.什么是分布式存储？</a></li>
                    <li>
                        <a href="#38%e4%bd%a0%e6%89%80%e7%9f%a5%e9%81%93%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e7%88%ac%e8%99%ab%e6%96%b9%e6%a1%88%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="38.你所知道的分布式爬虫方案有哪些？">38.你所知道的分布式爬虫方案有哪些？</a></li>
                    <li>
                        <a href="#39scrapy-redis%e6%9c%89%e5%81%9a%e8%bf%87%e5%85%b6%e4%bb%96%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e7%88%ac%e8%99%ab%e5%90%97" aria-label="39.scrapy-redis，有做过其他的分布式爬虫吗？">39.scrapy-redis，有做过其他的分布式爬虫吗？</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="数据库">数据库</a><ul>
                            
                    <li>
                        <a href="#mysql" aria-label="MySQL">MySQL</a><ul>
                            
                    <li>
                        <a href="#1%e4%b8%bb%e9%94%ae-%e8%b6%85%e9%94%ae-%e5%80%99%e9%80%89%e9%94%ae-%e5%a4%96%e9%94%ae" aria-label="1.主键 超键 候选键 外键">1.主键 超键 候选键 外键</a></li>
                    <li>
                        <a href="#2%e8%a7%86%e5%9b%be%e7%9a%84%e4%bd%9c%e7%94%a8%e8%a7%86%e5%9b%be%e5%8f%af%e4%bb%a5%e6%9b%b4%e6%94%b9%e4%b9%88" aria-label="2.视图的作用，视图可以更改么？">2.视图的作用，视图可以更改么？</a></li>
                    <li>
                        <a href="#3dropdelete%e4%b8%8etruncate%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="3.drop,delete与truncate的区别">3.drop,delete与truncate的区别</a></li>
                    <li>
                        <a href="#4%e7%b4%a2%e5%bc%95%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e5%8f%8a%e5%85%b6%e7%a7%8d%e7%b1%bb" aria-label="4.索引的工作原理及其种类">4.索引的工作原理及其种类</a></li>
                    <li>
                        <a href="#5%e8%bf%9e%e6%8e%a5%e7%9a%84%e7%a7%8d%e7%b1%bb" aria-label="5.连接的种类">5.连接的种类</a></li>
                    <li>
                        <a href="#6%e6%95%b0%e6%8d%ae%e5%ba%93%e4%bc%98%e5%8c%96%e7%9a%84%e6%80%9d%e8%b7%af" aria-label="6.数据库优化的思路">6.数据库优化的思路</a></li>
                    <li>
                        <a href="#7%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e4%b8%8e%e8%a7%a6%e5%8f%91%e5%99%a8%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="7.存储过程与触发器的区别">7.存储过程与触发器的区别</a></li>
                    <li>
                        <a href="#8%e6%82%b2%e8%a7%82%e9%94%81%e5%92%8c%e4%b9%90%e8%a7%82%e9%94%81%e6%98%af%e4%bb%80%e4%b9%88" aria-label="8.悲观锁和乐观锁是什么？">8.悲观锁和乐观锁是什么？</a></li>
                    <li>
                        <a href="#9%e4%bd%a0%e5%b8%b8%e7%94%a8%e7%9a%84mysql%e5%bc%95%e6%93%8e%e6%9c%89%e5%93%aa%e4%ba%9b%e5%90%84%e5%bc%95%e6%93%8e%e9%97%b4%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="9.你常用的mysql引擎有哪些?各引擎间有什么区别?">9.你常用的mysql引擎有哪些?各引擎间有什么区别?</a></li></ul>
                    </li>
                    <li>
                        <a href="#redis" aria-label="Redis">Redis</a><ul>
                            
                    <li>
                        <a href="#1redis%e5%ae%95%e6%9c%ba%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3" aria-label="1.Redis宕机怎么解决?">1.Redis宕机怎么解决?</a></li>
                    <li>
                        <a href="#2redis%e5%92%8cmecached%e7%9a%84%e5%8c%ba%e5%88%ab%e4%bb%a5%e5%8f%8a%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="2.redis和mecached的区别，以及使用场景">2.redis和mecached的区别，以及使用场景</a></li>
                    <li>
                        <a href="#3redis%e9%9b%86%e7%be%a4%e6%96%b9%e6%a1%88%e8%af%a5%e6%80%8e%e4%b9%88%e5%81%9a%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b%e6%96%b9%e6%a1%88" aria-label="3.Redis集群方案该怎么做?都有哪些方案?">3.Redis集群方案该怎么做?都有哪些方案?</a></li>
                    <li>
                        <a href="#4redis%e5%9b%9e%e6%94%b6%e8%bf%9b%e7%a8%8b%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84" aria-label="4.Redis回收进程是如何工作的">4.Redis回收进程是如何工作的</a></li></ul>
                    </li>
                    <li>
                        <a href="#mongodb" aria-label="MongoDB">MongoDB</a><ul>
                            
                    <li>
                        <a href="#1mongodb%e4%b8%ad%e5%af%b9%e5%a4%9a%e6%9d%a1%e8%ae%b0%e5%bd%95%e5%81%9a%e6%9b%b4%e6%96%b0%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4%e6%98%af%e4%bb%80%e4%b9%88" aria-label="1.MongoDB中对多条记录做更新操作命令是什么？">1.MongoDB中对多条记录做更新操作命令是什么？</a></li>
                    <li>
                        <a href="#2mongodb%e5%a6%82%e4%bd%95%e6%89%8d%e4%bc%9a%e6%8b%93%e5%b1%95%e5%88%b0%e5%a4%9a%e4%b8%aashard%e9%87%8c" aria-label="2.MongoDB如何才会拓展到多个shard里？">2.MongoDB如何才会拓展到多个shard里？</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%b5%8b%e8%af%95" aria-label="测试">测试</a><ul>
                            
                    <li>
                        <a href="#3%e7%bc%96%e5%86%99%e6%b5%8b%e8%af%95%e8%ae%a1%e5%88%92%e7%9a%84%e7%9b%ae%e7%9a%84%e6%98%af" aria-label="3.编写测试计划的目的是">3.编写测试计划的目的是</a></li>
                    <li>
                        <a href="#4%e5%af%b9%e5%85%b3%e9%94%ae%e8%af%8d%e8%a7%a6%e5%8f%91%e6%a8%a1%e5%9d%97%e8%bf%9b%e8%a1%8c%e6%b5%8b%e8%af%95" aria-label="4.对关键词触发模块进行测试">4.对关键词触发模块进行测试</a></li>
                    <li>
                        <a href="#5%e5%85%b6%e4%bb%96%e5%b8%b8%e7%94%a8%e7%ac%94%e8%af%95%e9%a2%98%e7%9b%ae%e7%bd%91%e5%9d%80%e6%b1%87%e6%80%bb" aria-label="5.其他常用笔试题目网址汇总">5.其他常用笔试题目网址汇总</a></li>
                    <li>
                        <a href="#6%e6%b5%8b%e8%af%95%e4%ba%ba%e5%91%98%e5%9c%a8%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e4%bb%bb%e5%8a%a1%e6%98%af%e4%bb%80%e4%b9%88" aria-label="6.测试人员在软件开发过程中的任务是什么">6.测试人员在软件开发过程中的任务是什么</a></li>
                    <li>
                        <a href="#7%e4%b8%80%e6%9d%a1%e8%bd%af%e4%bb%b6bug%e8%ae%b0%e5%bd%95%e9%83%bd%e5%8c%85%e5%90%ab%e4%ba%86%e5%93%aa%e4%ba%9b%e5%86%85%e5%ae%b9" aria-label="7.一条软件Bug记录都包含了哪些内容？">7.一条软件Bug记录都包含了哪些内容？</a></li>
                    <li>
                        <a href="#8%e7%ae%80%e8%bf%b0%e9%bb%91%e7%9b%92%e6%b5%8b%e8%af%95%e5%92%8c%e7%99%bd%e7%9b%92%e6%b5%8b%e8%af%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="8.简述黑盒测试和白盒测试的优缺点">8.简述黑盒测试和白盒测试的优缺点</a></li>
                    <li>
                        <a href="#9%e8%af%b7%e5%88%97%e5%87%ba%e4%bd%a0%e6%89%80%e7%9f%a5%e9%81%93%e7%9a%84%e8%bd%af%e4%bb%b6%e6%b5%8b%e8%af%95%e7%a7%8d%e7%b1%bb%e8%87%b3%e5%b0%915%e9%a1%b9" aria-label="9.请列出你所知道的软件测试种类，至少5项">9.请列出你所知道的软件测试种类，至少5项</a></li>
                    <li>
                        <a href="#10alpha%e6%b5%8b%e8%af%95%e4%b8%8ebeta%e6%b5%8b%e8%af%95%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="10.Alpha测试与Beta测试的区别是什么？">10.Alpha测试与Beta测试的区别是什么？</a></li>
                    <li>
                        <a href="#11%e4%b8%be%e4%be%8b%e8%af%b4%e6%98%8e%e4%bb%80%e4%b9%88%e6%98%afbug%e4%b8%80%e4%b8%aabug-report%e5%ba%94%e5%8c%85%e5%90%ab%e4%bb%80%e4%b9%88%e5%85%b3%e9%94%ae%e5%ad%97" aria-label="11.举例说明什么是Bug？一个bug report应包含什么关键字？">11.举例说明什么是Bug？一个bug report应包含什么关键字？</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%a4%a7%e6%95%b0%e6%8d%ae" aria-label="大数据">大数据</a><ul>
                            
                    <li>
                        <a href="#1%e6%89%be%e5%87%ba1g%e7%9a%84%e6%96%87%e4%bb%b6%e4%b8%ad%e9%ab%98%e9%a2%91%e8%af%8d" aria-label="1.找出1G的文件中高频词">1.找出1G的文件中高频词</a></li>
                    <li>
                        <a href="#2%e4%b8%80%e4%b8%aa%e5%a4%a7%e7%ba%a6%e6%9c%89%e4%b8%80%e4%b8%87%e8%a1%8c%e7%9a%84%e6%96%87%e6%9c%ac%e6%96%87%e4%bb%b6%e7%bb%9f%e8%ae%a1%e9%ab%98%e9%a2%91%e8%af%8d" aria-label="2.一个大约有一万行的文本文件统计高频词">2.一个大约有一万行的文本文件统计高频词</a></li>
                    <li>
                        <a href="#3%e6%80%8e%e4%b9%88%e5%9c%a8%e6%b5%b7%e9%87%8f%e6%95%b0%e6%8d%ae%e4%b8%ad%e6%89%be%e5%87%ba%e9%87%8d%e5%a4%8d%e6%ac%a1%e6%95%b0%e6%9c%80%e5%a4%9a%e7%9a%84%e4%b8%80%e4%b8%aa" aria-label="3.怎么在海量数据中找出重复次数最多的一个？">3.怎么在海量数据中找出重复次数最多的一个？</a></li>
                    <li>
                        <a href="#4%e5%88%a4%e6%96%ad%e6%95%b0%e6%8d%ae%e6%98%af%e5%90%a6%e5%9c%a8%e5%a4%a7%e9%87%8f%e6%95%b0%e6%8d%ae%e4%b8%ad" aria-label="4.判断数据是否在大量数据中">4.判断数据是否在大量数据中</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="python基础">Python基础<a hidden class="anchor" aria-hidden="true" href="#python基础">#</a></h1>
<h3 id="1python新式类和经典类的区别">1.python新式类和经典类的区别？<a hidden class="anchor" aria-hidden="true" href="#1python新式类和经典类的区别">#</a></h3>
<p>a. 在python里凡是继承了object的类，都是新式类</p>
<p>b. Python3里只有新式类</p>
<p>c. Python2里面继承object的是新式类，没有写父类的是经典类</p>
<p>d. 经典类目前在Python里基本没有应用</p>
<p>e. 保持class与type的统一对新式类的实例执行a.__class__与type(a)的结果是一致的，对于旧式类来说就不一样了。</p>
<p>f. 对于多重继承的属性搜索顺序不一样新式类是采用广度优先搜索，旧式类采用深度优先搜索。</p>
<h3 id="2python中内置的数据结构有几种">2.python中内置的数据结构有几种？<a hidden class="anchor" aria-hidden="true" href="#2python中内置的数据结构有几种">#</a></h3>
<p>a. 整型 int、 长整型 long、浮点型 float、 复数 complex</p>
<p>b. 字符串 str、 列表 list、 元组 tuple</p>
<p>c. 字典 dict 、 集合 set</p>
<p>d. Python3 中没有 long，只有无限精度的 int</p>
<h3 id="3python如何实现单例模式请写出两种实现方式">3.python如何实现单例模式?请写出两种实现方式?<a hidden class="anchor" aria-hidden="true" href="#3python如何实现单例模式请写出两种实现方式">#</a></h3>
<p>第一种方法:使用装饰器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">singleton</span>(cls):
</span></span><span style="display:flex;"><span>    instances <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> cls <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> instances:
</span></span><span style="display:flex;"><span>            instances[cls] <span style="color:#f92672">=</span> cls(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> instances[cls]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wrapper
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@singleton</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span>(object):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>foo1 <span style="color:#f92672">=</span> Foo()
</span></span><span style="display:flex;"><span>foo2 <span style="color:#f92672">=</span> Foo()
</span></span><span style="display:flex;"><span>print(foo1 <span style="color:#f92672">is</span> foo2)  <span style="color:#75715e"># True</span>
</span></span></code></pre></div><p>第二种方法：使用基类
New 是真正创建实例对象的方法，所以重写基类的new 方法，以此保证创建对象的时候只生成一个实例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span>(object):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __new__(cls, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> hasattr(cls, <span style="color:#e6db74">&#39;_instance&#39;</span>):
</span></span><span style="display:flex;"><span>            cls<span style="color:#f92672">.</span>_instance <span style="color:#f92672">=</span> super(Singleton, cls)<span style="color:#f92672">.</span>__new__(cls, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cls<span style="color:#f92672">.</span>_instance
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span>(Singleton):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo1 <span style="color:#f92672">=</span> Foo()
</span></span><span style="display:flex;"><span>foo2 <span style="color:#f92672">=</span> Foo()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(foo1 <span style="color:#f92672">is</span> foo2)  <span style="color:#75715e"># True</span>
</span></span></code></pre></div><p>第三种方法：元类，元类是用于创建类对象的类，类对象创建实例对象时一定要调用call方法，因此在调用call时候保证始终只创建一个实例即可，type是python的元类</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span>(type):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __call__(cls, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> hasattr(cls, <span style="color:#e6db74">&#39;_instance&#39;</span>):
</span></span><span style="display:flex;"><span>            cls<span style="color:#f92672">.</span>_instance <span style="color:#f92672">=</span> super(Singleton, cls)<span style="color:#f92672">.</span>__call__(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cls<span style="color:#f92672">.</span>_instance
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Python2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span>(object):
</span></span><span style="display:flex;"><span>    __metaclass__ <span style="color:#f92672">=</span> Singleton
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Python3</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span>(metaclass<span style="color:#f92672">=</span>Singleton):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo1 <span style="color:#f92672">=</span> Foo()
</span></span><span style="display:flex;"><span>foo2 <span style="color:#f92672">=</span> Foo()
</span></span><span style="display:flex;"><span>print(foo1 <span style="color:#f92672">is</span> foo2)  <span style="color:#75715e"># True</span>
</span></span></code></pre></div><h3 id="4可变类型和不可变类型">4.可变类型和不可变类型<a hidden class="anchor" aria-hidden="true" href="#4可变类型和不可变类型">#</a></h3>
<p>1,可变类型有list,dict.不可变类型有string,number,tuple.</p>
<p>2,当进行修改操作时，可变类型传递的是内存中的地址，也就是说，直接修改内存中的值，并没有开辟新的内存。</p>
<p>3,不可变类型被改变时，并没有改变原内存地址中的值，而是开辟一块新的内存，将原地址中的值复制过去，对这块新开辟的内存中的值进行操作。</p>
<h3 id="5is和有什么区别">5.is和==有什么区别？<a hidden class="anchor" aria-hidden="true" href="#5is和有什么区别">#</a></h3>
<p>is：比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象。是否指向同一个内存地址</p>
<p>== ： 比较的两个对象的内容/值是否相等，默认会调用对象的eq()方法</p>
<h3 id="6python中变量的作用域变量查找顺序">6.Python中变量的作用域？（变量查找顺序)<a hidden class="anchor" aria-hidden="true" href="#6python中变量的作用域变量查找顺序">#</a></h3>
<p>函数作用域的LEGB顺序</p>
<p>1.什么是LEGB?</p>
<p>L: local 函数内部作用域</p>
<p>E: enclosing 函数内部与内嵌函数之间</p>
<p>G: global 全局作用域</p>
<p>B: build-in 内置作用</p>
<p>python在函数里面的查找分为4种，称之为LEGB，也正是按照这是顺序来查找的</p>
<h3 id="7super函数的具体用法和场景">7.super函数的具体用法和场景<a hidden class="anchor" aria-hidden="true" href="#7super函数的具体用法和场景">#</a></h3>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p07_calling_method_on_parent_class.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p07_calling_method_on_parent_class.html</a></p>
<h1 id="python高级">Python高级<a hidden class="anchor" aria-hidden="true" href="#python高级">#</a></h1>
<h2 id="元类">元类<a hidden class="anchor" aria-hidden="true" href="#元类">#</a></h2>
<h3 id="1python中类方法类实例方法静态方法有何区别">1.Python中类方法、类实例方法、静态方法有何区别？<a hidden class="anchor" aria-hidden="true" href="#1python中类方法类实例方法静态方法有何区别">#</a></h3>
<p>类方法: 是类对象的方法，在定义时需要在上方使用 @classmethod 进行装饰,形参为cls，表示类对象，类对象和实例对象都可调用</p>
<p>类实例方法: 是类实例化对象的方法,只有实例对象可以调用，形参为self,指代对象本身;</p>
<p>静态方法: 是一个任意函数，在其上方使用 @staticmethod 进行装饰，可以用对象直接调用，静态方法实际上跟该类没有太大关系</p>
<h3 id="2介绍cythonpypy-cpython-numba各有什么缺点">2.介绍Cython，Pypy Cpython Numba各有什么缺点<a hidden class="anchor" aria-hidden="true" href="#2介绍cythonpypy-cpython-numba各有什么缺点">#</a></h3>
<p>Cython</p>
<h3 id="3请描述抽象类和接口类的区别和联系">3.请描述抽象类和接口类的区别和联系<a hidden class="anchor" aria-hidden="true" href="#3请描述抽象类和接口类的区别和联系">#</a></h3>
<p>1.抽象类： 规定了一系列的方法，并规定了必须由继承类实现的方法。由于有抽象方法的存在，所以抽象类不能实例化。可以将抽象类理解为毛坯房，门窗，墙面的样式由你自己来定，所以抽象类与作为基类的普通类的区别在于约束性更强</p>
<p>2.接口类：与抽象类很相似，表现在接口中定义的方法，必须由引用类实现，但他与抽象类的根本区别在于用途：与不同个体间沟通的规则，你要进宿舍需要有钥匙，这个钥匙就是你与宿舍的接口，你的舍友也有这个接口，所以他也能进入宿舍，你用手机通话，那么手机就是你与他人交流的接口</p>
<p>3.区别和关联：</p>
<p>1.接口是抽象类的变体，接口中所有的方法都是抽象的，而抽象类中可以有非抽象方法，抽象类是声明方法的存在而不去实现它的类</p>
<p>2.接口可以继承，抽象类不行</p>
<p>3.接口定义方法，没有实现的代码，而抽象类可以实现部分方法</p>
<p>4.接口中基本数据类型为static而抽象类不是</p>
<h2 id="什么是python中的gil">什么是Python中的GIL？<a hidden class="anchor" aria-hidden="true" href="#什么是python中的gil">#</a></h2>
<p>全局解释器锁 GIL，对于每一个进程都具有一个 GIL ，它的直接作用是限制单个进程中多线程的并行执行，使得即使在多核处理器上对于单个进程来说，在同一时刻运行的线程仅限一个。</p>
<p><strong>Python的多线程是伪多线程，无法利用多核资源，同一个时刻只有一个线程在真正的运行。</strong></p>
<h2 id="内存管理与垃圾回收机制">内存管理与垃圾回收机制<a hidden class="anchor" aria-hidden="true" href="#内存管理与垃圾回收机制">#</a></h2>
<h3 id="1哪些操作会导致python内存溢出怎么处理">1.哪些操作会导致Python内存溢出，怎么处理？<a hidden class="anchor" aria-hidden="true" href="#1哪些操作会导致python内存溢出怎么处理">#</a></h3>
<h3 id="2关于python内存管理下列说法错误的是--b">2.关于Python内存管理,下列说法错误的是  B<a hidden class="anchor" aria-hidden="true" href="#2关于python内存管理下列说法错误的是--b">#</a></h3>
<p>A,变量不必事先声明                                   B,变量无须先创建和赋值而直接使用</p>
<p>C,变量无须指定类型                                   D,可以使用del释放资源</p>
<h3 id="3python的内存管理机制及调优手段">3.Python的内存管理机制及调优手段？<a hidden class="anchor" aria-hidden="true" href="#3python的内存管理机制及调优手段">#</a></h3>
<p>内存管理机制: 引用计数、垃圾回收、内存池</p>
<p>引用计数：引用计数是一种非常高效的内存管理手段，当一个Python对象被引用时其引用计数增加1,</p>
<p>当其不再被一个变量引用时则计数减1,当引用计数等于0时对象被删除。弱引用不会增加引用计数</p>
<p>垃圾回收：</p>
<p>1.引用计数</p>
<p>引用计数也是一种垃圾收集机制，而且也是一种最直观、最简单的垃圾收集技术。当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1，如果引用被删除，对象的引用计数为0,那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了。</p>
<p>2.标记清除</p>
<p>标记清除主要是解决循环引用问题。</p>
<p>标记清除算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。</p>
<p>它分为两个阶段：第一阶段是标记阶段，GC 会把所有的 活动对象 打上标记，第二阶段是把那些没有标记的对象 非活动对象 进行回收。那么 GC 又是如何判断哪些是活动对象哪些是非活动对象的呢？</p>
<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p>
<p>3.分代技术</p>
<p>分代回收是一种以空间换时间的操作方式。</p>
<p>Python 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python 将内存分为了 3“代”，分别为年轻代（第 0 代）、中年代（第 1 代）、老年代（第 2 代），他们对应的是 3 个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。</p>
<p>调优手段</p>
<p>1.手动垃圾回收</p>
<p>2.调高垃圾回收阈值</p>
<p>3.避免循环引用</p>
<h3 id="4内存泄露是什么如何避免">4.内存泄露是什么？如何避免？<a hidden class="anchor" aria-hidden="true" href="#4内存泄露是什么如何避免">#</a></h3>
<p><strong>内存泄漏</strong>指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>
<p>有<code>__del__()</code>函数的对象间的循环引用是导致内存泄露的主凶。不使用一个对象时使用: del object 来删除一个对象的引用计数就可以有效防止内存泄露问题。</p>
<p>通过Python扩展模块gc 来查看不能回收的对象的详细信息。</p>
<p>可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为0来判断是否内存泄露</p>
<h2 id="函数">函数<a hidden class="anchor" aria-hidden="true" href="#函数">#</a></h2>
<h3 id="1简述readreadlinereadlines的区别">1.简述read、readline、readlines的区别？<a hidden class="anchor" aria-hidden="true" href="#1简述readreadlinereadlines的区别">#</a></h3>
<p>read                           读取整个文件</p>
<p>readline                     读取下一行</p>
<p>readlines                   读取整个文件到一个迭代器以供我们遍历</p>
<h3 id="2什么是hash散列函数">2.什么是Hash（散列函数）？<a hidden class="anchor" aria-hidden="true" href="#2什么是hash散列函数">#</a></h3>
<p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表</p>
<h3 id="3python函数重载机制">3.python函数重载机制？<a hidden class="anchor" aria-hidden="true" href="#3python函数重载机制">#</a></h3>
<p>函数重载主要是为了解决两个问题。
1。可变参数类型。
2。可变参数个数。</p>
<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>
<p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p>
<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p>
<p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p>
<h3 id="4函数调用参数的传递方式是值传递还是引用传递">4.函数调用参数的传递方式是值传递还是引用传递？<a hidden class="anchor" aria-hidden="true" href="#4函数调用参数的传递方式是值传递还是引用传递">#</a></h3>
<p>Python的参数传递有：位置参数、默认参数、可变参数、关键字参数。</p>
<p>函数的传值到底是值传递还是引用传递、要分情况：</p>
<p>不可变参数用值传递：像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。</p>
<p>可变参数是引用传递：比如像列表，字典这样的对象是通过引用传递、和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。</p>
<h3 id="5如何在function里面设置一个全局变量">5.如何在function里面设置一个全局变量<a hidden class="anchor" aria-hidden="true" href="#5如何在function里面设置一个全局变量">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>globals() <span style="color:#75715e"># 返回包含当前作用余全局变量的字典。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">global</span> 变量 设置使用全局变量
</span></span></code></pre></div><h3 id="6对缺省参数的理解-">6.对缺省参数的理解 ？<a hidden class="anchor" aria-hidden="true" href="#6对缺省参数的理解-">#</a></h3>
<p>缺省参数指在调用函数的时候没有传入参数的情况下，调用默认的参数，在调用函数的同时赋值时，所传入的参数会替代默认参数。</p>
<p>*args是不定长参数，它可以表示输入参数是不确定的，可以是任意多个。</p>
<p>**kwargs是关键字参数，赋值的时候是以键值对的方式，参数可以是任意多对在定义函数的时候</p>
<p>不确定会有多少参数会传入时，就可以使用两个参数</p>
<h3 id="7mysql怎么限制ip访问">7.Mysql怎么限制IP访问？<a hidden class="anchor" aria-hidden="true" href="#7mysql怎么限制ip访问">#</a></h3>
<h3 id="8带参数的装饰器">8.带参数的装饰器?<a hidden class="anchor" aria-hidden="true" href="#8带参数的装饰器">#</a></h3>
<p>带定长参数的装饰器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">new_func</span>(func):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrappedfun</span>(username, passwd):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> username <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;root&#39;</span> <span style="color:#f92672">and</span> passwd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;123456789&#39;</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;通过认证&#39;</span>)
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;开始执行附加功能&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> func()
</span></span><span style="display:flex;"><span>       	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;用户名或密码错误&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wrappedfun
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@new_func</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">origin</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;开始执行函数&#39;</span>)
</span></span><span style="display:flex;"><span>origin(<span style="color:#e6db74">&#39;root&#39;</span>,<span style="color:#e6db74">&#39;123456789&#39;</span>)
</span></span></code></pre></div><p>带不定长参数的装饰器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">new_func</span>(func):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrappedfun</span>(<span style="color:#f92672">*</span>parts):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> parts:
</span></span><span style="display:flex;"><span>            counts <span style="color:#f92672">=</span> len(parts)
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;本系统包含 &#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> part <span style="color:#f92672">in</span> parts:
</span></span><span style="display:flex;"><span>                print(part, <span style="color:#e6db74">&#39; &#39;</span>,end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;等&#39;</span>, counts, <span style="color:#e6db74">&#39;部分&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> func()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;用户名或密码错误&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> func()
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> wrappedfun
</span></span></code></pre></div><h3 id="9为什么函数名字可以当做参数用">9.为什么函数名字可以当做参数用?<a hidden class="anchor" aria-hidden="true" href="#9为什么函数名字可以当做参数用">#</a></h3>
<p>Python中一切皆对象，函数名是函数在内存中的空间，也是一个对象</p>
<h3 id="10map函数和reduce函数">10.map函数和reduce函数？<a hidden class="anchor" aria-hidden="true" href="#10map函数和reduce函数">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>map(<span style="color:#66d9ef">lambda</span> x: x <span style="color:#f92672">*</span> x, [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>])   <span style="color:#75715e"># 使用 lambda</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># [1, 4, 9, 16]</span>
</span></span><span style="display:flex;"><span>reduce(<span style="color:#66d9ef">lambda</span> x, y: x <span style="color:#f92672">*</span> y, [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>])  <span style="color:#75715e"># 相当于 ((1 * 2) * 3) * 4</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 24</span>
</span></span></code></pre></div><h3 id="11回调函数如何通信的">11.回调函数，如何通信的?<a hidden class="anchor" aria-hidden="true" href="#11回调函数如何通信的">#</a></h3>
<p>回调函数是把函数的指针(地址)作为参数传递给另一个函数，将整个函数当作一个对象，赋值给调用的函数。</p>
<h3 id="12python主要的内置数据类型都有哪些-print-dir-a--的输出">12.Python主要的内置数据类型都有哪些？ print dir( ‘a ’) 的输出？<a hidden class="anchor" aria-hidden="true" href="#12python主要的内置数据类型都有哪些-print-dir-a--的输出">#</a></h3>
<p>内建类型：布尔类型，数字，字符串，列表，元组，字典，集合</p>
<p>输出字符串&rsquo;a&rsquo;的内建方法</p>
<h3 id="13hasattr-getattr-setattr-函数使用详解">13.hasattr() getattr() setattr() 函数使用详解？<a hidden class="anchor" aria-hidden="true" href="#13hasattr-getattr-setattr-函数使用详解">#</a></h3>
<p>hasattr(object,name)函数:</p>
<p>判断一个对象里面是否有name属性或者name方法，返回bool值，有name属性（方法）返回True，否则返回False。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">function_demo</span>(object):
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;demo&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;hello function&#34;</span>
</span></span><span style="display:flex;"><span>functiondemo <span style="color:#f92672">=</span> function_demo()
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> hasattr(functiondemo, <span style="color:#e6db74">&#34;name&#34;</span>) <span style="color:#75715e"># 判断对象是否有name属性，True</span>
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> hasattr(functiondemo, <span style="color:#e6db74">&#34;run&#34;</span>) <span style="color:#75715e"># 判断对象是否有run方法，True</span>
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> hasattr(functiondemo, <span style="color:#e6db74">&#34;age&#34;</span>) <span style="color:#75715e"># 判断对象是否有age属性，False</span>
</span></span><span style="display:flex;"><span>print(res)
</span></span></code></pre></div><p>getattr(object, name[,default])函数：</p>
<p>获取对象object的属性或者方法，如果存在则打印出来，如果不存在，打印默认值，默认值可选。注意：如果返回的是对象的方法，则打印结果是：方法的内存地址，如果需要运行这个方法，可以在后面添加括号().</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>functiondemo <span style="color:#f92672">=</span> function_demo()
</span></span><span style="display:flex;"><span>getattr(functiondemo, <span style="color:#e6db74">&#34;name&#34;</span>)<span style="color:#75715e"># 获取name属性，存在就打印出来 --- demo</span>
</span></span><span style="display:flex;"><span>getattr(functiondemo, <span style="color:#e6db74">&#34;run&#34;</span>) <span style="color:#75715e"># 获取run 方法，存在打印出方法的内存地址</span>
</span></span><span style="display:flex;"><span>getattr(functiondemo, <span style="color:#e6db74">&#34;age&#34;</span>) <span style="color:#75715e"># 获取不存在的属性，报错</span>
</span></span><span style="display:flex;"><span>getattr(functiondemo, <span style="color:#e6db74">&#34;age&#34;</span>, <span style="color:#ae81ff">18</span>)<span style="color:#75715e"># 获取不存在的属性，返回一个默认值</span>
</span></span></code></pre></div><p>setattr(object, name, values)函数：</p>
<p>给对象的属性赋值，若属性不存在，先创建再赋值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">function_demo</span>(object):
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;demo&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;hello function&#34;</span>
</span></span><span style="display:flex;"><span>functiondemo <span style="color:#f92672">=</span> function_demo()
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> hasattr(functiondemo, <span style="color:#e6db74">&#34;age&#34;</span>) <span style="color:#75715e"># 判断age属性是否存在，False</span>
</span></span><span style="display:flex;"><span>print(res)
</span></span><span style="display:flex;"><span>setattr(functiondemo, <span style="color:#e6db74">&#34;age&#34;</span>, <span style="color:#ae81ff">18</span>) <span style="color:#75715e"># 对age属性进行赋值，无返回值</span>
</span></span><span style="display:flex;"><span>res1 <span style="color:#f92672">=</span> hasattr(functiondemo, <span style="color:#e6db74">&#34;age&#34;</span>) <span style="color:#75715e"># 再次判断属性是否存在，True</span>
</span></span></code></pre></div><p>综合使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">function_demo</span>(object):
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;demo&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;hello function&#34;</span>
</span></span><span style="display:flex;"><span>functiondemo <span style="color:#f92672">=</span> function_demo()
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> hasattr(functiondemo, <span style="color:#e6db74">&#34;addr&#34;</span>) <span style="color:#75715e"># 先判断是否存在</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> res:
</span></span><span style="display:flex;"><span>    addr <span style="color:#f92672">=</span> getattr(functiondemo, <span style="color:#e6db74">&#34;addr&#34;</span>)
</span></span><span style="display:flex;"><span>    print(addr)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    addr <span style="color:#f92672">=</span> getattr(functiondemo, <span style="color:#e6db74">&#34;addr&#34;</span>, setattr(functiondemo, <span style="color:#e6db74">&#34;addr&#34;</span>, <span style="color:#e6db74">&#34;北京首都&#34;</span>))
</span></span><span style="display:flex;"><span>    print(addr)
</span></span></code></pre></div><h3 id="14什么是lambda函数-有什么好处">14.什么是lambda函数？ 有什么好处？<a hidden class="anchor" aria-hidden="true" href="#14什么是lambda函数-有什么好处">#</a></h3>
<p>lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数</p>
<p>1.lambda函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用，连名字都很随意的情况下</p>
<p>2.匿名函数，一般用来给filter，map这样的函数式编程服务</p>
<p>3.作为回调函数，传递给某些应用，比如消息处理</p>
<h3 id="15递归函数停止的条件">15.递归函数停止的条件？<a hidden class="anchor" aria-hidden="true" href="#15递归函数停止的条件">#</a></h3>
<p>递归的终止条件一般定义在递归函数内部，在递归调用前要做一个条件判断，根据判断的结果选择是继续调用自身，还是return，，返回终止递归。</p>
<p>终止的条件：判断递归的次数是否达到某一限定值</p>
<p>2.判断运算的结果是否达到某个范围等，根据设计的目的来选择</p>
<h3 id="16什么是lambda函数它有什么好处写一个匿名函数求两个数的和">16.什么是lambda函数？它有什么好处？写一个匿名函数求两个数的和<a hidden class="anchor" aria-hidden="true" href="#16什么是lambda函数它有什么好处写一个匿名函数求两个数的和">#</a></h3>
<p>lambda函数是匿名函数，使用lambda函数能创建小型匿名函数，这种函数得名于省略了用def声明函数的标准步骤</p>
<h2 id="设计模式">设计模式<a hidden class="anchor" aria-hidden="true" href="#设计模式">#</a></h2>
<h3 id="1对设计模式的理解简述你了解的设计模式">1.对设计模式的理解，简述你了解的设计模式？<a hidden class="anchor" aria-hidden="true" href="#1对设计模式的理解简述你了解的设计模式">#</a></h3>
<p>设计模式是经过总结，优化的，对我们经常会碰到的一些编程问题的可重用解决方案。一个设计模式并不像一个类或一个库那样能够直接作用于我们的代码，反之，设计模式更为高级，它是一种必须在特定情形下实现的一种方法模板。
常见的是工厂模式和单例模式</p>
<h3 id="2请手写一个单例">2.请手写一个单例<a hidden class="anchor" aria-hidden="true" href="#2请手写一个单例">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#python2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>(object):
</span></span><span style="display:flex;"><span>    __instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __new__(cls,<span style="color:#f92672">*</span>args,<span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> cls<span style="color:#f92672">.</span>__instance <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>            cls<span style="color:#f92672">.</span>__instance <span style="color:#f92672">=</span> objecet<span style="color:#f92672">.</span>__new__(cls)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> cls<span style="color:#f92672">.</span>__instance
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> cls<span style="color:#f92672">.</span>__instance
</span></span></code></pre></div><h3 id="3单例模式的应用场景有那些">3.单例模式的应用场景有那些？<a hidden class="anchor" aria-hidden="true" href="#3单例模式的应用场景有那些">#</a></h3>
<p>单例模式应用的场景一般发现在以下条件下：
资源共享的情况下，避免由于资源操作时导致的性能或损耗等，如日志文件，应用配置。
控制资源的情况下，方便资源之间的互相通信。如线程池等，1,网站的计数器 2,应用配置 3.多线程池 4数据库配置 数据库连接池 5.应用程序的日志应用&hellip;</p>
<h3 id="4对装饰器的理解并写出一个计时器记录方法执行性能的装饰器">4.对装饰器的理解，并写出一个计时器记录方法执行性能的装饰器？<a hidden class="anchor" aria-hidden="true" href="#4对装饰器的理解并写出一个计时器记录方法执行性能的装饰器">#</a></h3>
<p>装饰器本质上是一个callable object ，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> functools <span style="color:#f92672">import</span> wraps
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">timeit</span>(func):
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@wraps</span>(func)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>clock()
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        end <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>clock()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;used:&#39;</span>,end<span style="color:#f92672">-</span>start)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wrapper
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@timeit</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;in foo()&#39;</span>foo())
</span></span></code></pre></div><h3 id="5解释以下什么是闭包">5.解释以下什么是闭包？<a hidden class="anchor" aria-hidden="true" href="#5解释以下什么是闭包">#</a></h3>
<p>在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。</p>
<h3 id="6函数装饰器有什么作用">6.函数装饰器有什么作用？<a hidden class="anchor" aria-hidden="true" href="#6函数装饰器有什么作用">#</a></h3>
<p>装饰器本质上是一个callable object，它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能。装饰器的返回值也是一个函数的对象，它经常用于有切面需求的场景。比如：插入日志，性能测试，事务处理，缓存。权限的校验等场景，有了装饰器就可以抽离出大量的与函数功能本身无关的雷同代码并发并继续使用。
详细参考：https://manjusaka.itscoder.com/2018/02/23/something-about-decorator/</p>
<h3 id="7生成器迭代器的区别">7.生成器，迭代器的区别？<a hidden class="anchor" aria-hidden="true" href="#7生成器迭代器的区别">#</a></h3>
<p>迭代器是遵循迭代协议的对象。用户可以使用 iter() 以从任何序列得到迭代器（如 list, tuple, dictionary, set 等）。另一个方法则是创建一个另一种形式的迭代器 —— generator 。要获取下一个元素，则使用成员函数 next()（Python 2）或函数 next() function （Python 3） 。当没有元素时，则引发 StopIteration 此例外。若要实现自己的迭代器，则只要实现 next()（Python 2）或 <code>__next__</code>()（ Python 3）</p>
<p>生成器（Generator），只是在需要返回数据的时候使用yield语句。每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）</p>
<p>区别： 生成器能做到迭代器能做的所有事，而且因为自动创建iter()和next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。</p>
<p>官方介绍：https://docs.python.org/3/tutorial/classes.html#iterators</p>
<h3 id="8python中yield的用法">8.Python中yield的用法?<a hidden class="anchor" aria-hidden="true" href="#8python中yield的用法">#</a></h3>
<p>yield就是保存当前程序执行状态。你用for循环的时候，每次取一个元素的时候就会计算一次。用yield的函数叫generator,和iterator一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间，generator每次计算需要上一次计算结果，所以用yield,否则一return，上次计算结果就没了</p>
<h2 id="面向对象">面向对象<a hidden class="anchor" aria-hidden="true" href="#面向对象">#</a></h2>
<h3 id="1python中的可变对象和不可变对象">1.Python中的可变对象和不可变对象？<a hidden class="anchor" aria-hidden="true" href="#1python中的可变对象和不可变对象">#</a></h3>
<p>不可变对象，该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。</p>
<p>可变对象，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上其所指的值直接发生改变，并没有发生复制行为，也没有开辟出新的地址，通俗点说就是原地改变。</p>
<p>Pyhton中，数值类型(int 和float)，字符串str、元组tuple都是不可变类型。而列表list、字典dict、集合set是可变类型</p>
<h3 id="2python的魔法方法">2.Python的魔法方法<a hidden class="anchor" aria-hidden="true" href="#2python的魔法方法">#</a></h3>
<p>魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被Python所调用，你可以定义自己想要的行为，而这一切都是自动发生的，它们经常是两个下划线包围来命名的（比如<code>__init___</code>,<code>__len__</code>),Python的魔法方法是非常强大的所以了解其使用方法也变得尤为重要!</p>
<p><code>__init__</code>构造器，当一个实例被创建的时候初始化的方法，但是它并不是实例化调用的第一个方法。</p>
<p><code>__new__</code>才是实例化对象调用的第一个方法，它只取下cls参数，并把其他参数传给<code>__init___</code>.</p>
<p><code>___new__</code>很少使用，但是也有它适合的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。</p>
<p><code>__call__</code>让一个类的实例像函数一样被调用</p>
<p><code>__getitem__</code>定义获取容器中指定元素的行为，相当于self[key]</p>
<p><code>__getattr__</code>定义当用户试图访问一个不存在属性的时候的行为。</p>
<p><code>__setattr__</code>定义当一个属性被设置的时候的行为</p>
<p><code>__getattribute___</code>定义当一个属性被访问的时候的行为</p>
<h3 id="3面向对象中怎么实现只读属性">3.面向对象中怎么实现只读属性?<a hidden class="anchor" aria-hidden="true" href="#3面向对象中怎么实现只读属性">#</a></h3>
<p>将对象私有化，通过共有方法提供一个读取数据的接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">person</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, x):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">age</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>__age
</span></span><span style="display:flex;"><span>t <span style="color:#f92672">=</span> person(<span style="color:#ae81ff">22</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># t.__age =100</span>
</span></span><span style="display:flex;"><span>print(t<span style="color:#f92672">.</span>age())
</span></span></code></pre></div><p>最好的方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyCls</span>(object):
</span></span><span style="display:flex;"><span>    __weight <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@property</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">weight</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>__weight
</span></span><span style="display:flex;"><span>   
</span></span></code></pre></div><h3 id="4谈谈你对面向对象的理解">4.谈谈你对面向对象的理解？<a hidden class="anchor" aria-hidden="true" href="#4谈谈你对面向对象的理解">#</a></h3>
<p>面向对象是相当于面向过程而言的，面向过程语言是一种基于功能分析的，以算法为中心的程序设计方法，而面向对象是一种基于结构分析的，以数据为中心的程序设计思想。在面向对象语言中有一个很重要的东西，叫做类。面向对象有三大特性：封装、继承、多态。</p>
<h3 id="5python字符串查找和替换">5.Python字符串查找和替换？<a hidden class="anchor" aria-hidden="true" href="#5python字符串查找和替换">#</a></h3>
<pre><code>a、str.find()：正序字符串查找函数
函数原型：
str.find(substr [,pos_start [,pos_end ] ] )
返回str中第一次出现的substr的第一个字母的标号，如果str中没有substr则返回-1，也就是说从左边算起的第一次出现的substr的首字母标号。

参数说明：
str：代表原字符串
substr：代表要查找的字符串
pos_start：代表查找的开始位置，默认是从下标0开始查找
pos_end：代表查找的结束位置

例子：
'aabbcc.find('bb')' # 2

b、str.index()：正序字符串查找函数
index()函数类似于find()函数，在Python中也是在字符串中查找子串第一次出现的位置，跟find()不同的是，未找到则抛出异常。

函数原型：
str.index(substr [, pos_start, [ pos_end ] ] )

参数说明：
str：代表原字符串
substr：代表要查找的字符串
pos_start：代表查找的开始位置，默认是从下标0开始查找
pos_end：代表查找的结束位置

例子：
'acdd l1 23'.index(' ') # 4

c、str.rfind()：倒序字符串查找函数

函数原型：
str.rfind( substr [, pos_start [,pos_ end ] ])
返回str中最后出现的substr的第一个字母的标号，如果str中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号。

参数说明：
str：代表原字符串
substr：代表要查找的字符串
pos_start：代表查找的开始位置，默认是从下标0开始查找
pos_end：代表查找的结束位置

例子：
'adsfddf'.rfind('d') # 5

d、str.rindex()：倒序字符串查找函数
rindex()函数类似于rfind()函数，在Python中也是在字符串中倒序查找子串最后一次出现的位置，跟rfind()不同的是，未找到则抛出异常。

函数原型：
str.rindex(substr [, pos_start, [ pos_end ] ] )

参数说明：
str：代表原字符串
substr：代表要查找的字符串
pos_start：代表查找的开始位置，默认是从下标0开始查找
pos_end：代表查找的结束位置

例子：
 'adsfddf'.rindex('d') # 5

e、使用re模块进行查找和替换：
</code></pre>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.match(pat, s)</td>
<td>只从字符串s的头开始匹配，比如(‘123’, ‘12345’)匹配上了，而(‘123’,’01234’)就是没有匹配上，没有匹配上返回None，匹配上返回matchobject</td>
</tr>
<tr>
<td>re.search(pat, s)</td>
<td>从字符串s的任意位置都进行匹配，比如(‘123’,’01234’)就是匹配上了，只要s只能存在符合pat的连续字符串就算匹配上了，没有匹配上返回None，匹配上返回matchobject</td>
</tr>
<tr>
<td>re.sub(pat,newpat,s)</td>
<td>re.sub(pat,newpat,s)	对字符串中s的包含的所有符合pat的连续字符串进行替换，如果newpat为str,那么就是替换为newpat,如果newpat是函数，那么就按照函数返回值替换。sub函数两个有默认值的参数分别是count表示最多只处理前几个匹配的字符串，默认为0表示全部处理；最后一个是flags，默认为0</td>
</tr>
</tbody>
</table>
<pre><code>f、使用replace()进行替换：
基本用法：对象.replace(rgExp,replaceText,max)

其中，rgExp和replaceText是必须要有的，max是可选的参数，可以不加。
rgExp是指正则表达式模式或可用标志的正则表达式对象，也可以是 String 对象或文字；
replaceText是一个String 对象或字符串文字；
max是一个数字。
对于一个对象，在对象的每个rgExp都替换成replaceText，从左到右最多max次。

s1='hello world'
s1.replace('world','liming')
</code></pre>
<h3 id="6用python匹配html-tag的时候-和--有什么区别">6.用Python匹配HTML tag的时候，&lt;.<em>&gt; 和 &lt;.</em>?&gt; 有什么区别<a hidden class="anchor" aria-hidden="true" href="#6用python匹配html-tag的时候-和--有什么区别">#</a></h3>
<pre><code>第一个代表贪心匹配，第二个代表非贪心；
?在一般正则表达式里的语法是指的&quot;零次或一次匹配左边的字符或表达式&quot;相当于{0,1}
而当?后缀于*,+,?,{n},{n,},{n,m}之后，则代表非贪心匹配模式，也就是说，尽可能少的匹配左边的字符或表达式，这里是尽可能少的匹配.(任意字符)

所以：第一种写法是，尽可能多的匹配，就是匹配到的字符串尽量长，第二中写法是尽可能少的匹配，就是匹配到的字符串尽量短。
比如&lt;tag&gt;tag&gt;tag&gt;end，第一个会匹配&lt;tag&gt;tag&gt;tag&gt;,第二个会匹配&lt;tag&gt;。
</code></pre>
<h3 id="7正则表达式贪婪与非贪婪模式的区别">7.正则表达式贪婪与非贪婪模式的区别？<a hidden class="anchor" aria-hidden="true" href="#7正则表达式贪婪与非贪婪模式的区别">#</a></h3>
<pre><code>贪婪模式：
定义：正则表达式去匹配时，会尽量多的匹配符合条件的内容
标识符：+，?，*，{n}，{n,}，{n,m}
匹配时，如果遇到上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容

非贪婪模式：
定义：正则表达式去匹配时，会尽量少的匹配符合条件的内容 也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有g，开启下一组匹配)
标识符：+?，??，*?，{n}?，{n,}?，{n,m}?
可以看到，非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个?

参考文章：https://dailc.github.io/2017/07/06/regularExpressionGreedyAndLazy.html
</code></pre>
<h3 id="8怎么过滤评论中的表情">8.怎么过滤评论中的表情？<a hidden class="anchor" aria-hidden="true" href="#8怎么过滤评论中的表情">#</a></h3>
<pre><code>思路：主要是匹配表情包的范围，将表情包的范围用空替换掉
</code></pre>
<pre tabindex="0"><code>import re
pattern = re.compile(u&#39;[\uD800-\uDBFF][\uDC00-\uDFFF]&#39;)
pattern.sub(&#39;&#39;,text)
</code></pre><h3 id="9简述python里面search和match的区别">9.简述Python里面search和match的区别<a hidden class="anchor" aria-hidden="true" href="#9简述python里面search和match的区别">#</a></h3>
<pre><code>match()函数只检测字符串开头位置是否匹配，匹配成功才会返回结果，否则返回None；
search()函数会在整个字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。
</code></pre>
<h2 id="系统编程">系统编程<a hidden class="anchor" aria-hidden="true" href="#系统编程">#</a></h2>
<h3 id="1进程总结">1.进程总结<a hidden class="anchor" aria-hidden="true" href="#1进程总结">#</a></h3>
<p>进程：程序运行在操作系统上的一个实例，就称之为进程。进程需要相应的系统资源：内存、时间片、pid。
创建进程：
首先要导入multiprocessing中的Process：
创建一个Process对象;
创建Process对象时，可以传递参数;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>p <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>XXX,args<span style="color:#f92672">=</span>(tuple,),kwargs<span style="color:#f92672">=</span>{key:value})
</span></span><span style="display:flex;"><span>target <span style="color:#f92672">=</span> XXX 指定的任务函数<span style="color:#960050;background-color:#1e0010">，</span>不用加(),
</span></span><span style="display:flex;"><span>args<span style="color:#f92672">=</span>(tuple,)kwargs<span style="color:#f92672">=</span>{key:value}给任务函数传递的参数
</span></span></code></pre></div><p>使用start()启动进程
结束进程
给子进程指定函数传递参数Demo</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> mulitprocessing <span style="color:#f92672">import</span> Process
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pro_func</span>(name,age,<span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">5</span>):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;子进程正在运行中，name=</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">,age=</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">,pid=</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">%</span>(name,age,os<span style="color:#f92672">.</span>getpid()))
</span></span><span style="display:flex;"><span>        print(kwargs)
</span></span><span style="display:flex;"><span>        time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.2</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span><span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#创建Process对象</span>
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>pro_func,args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;小明&#39;</span>,<span style="color:#ae81ff">18</span>),kwargs<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#39;m&#39;</span>:<span style="color:#ae81ff">20</span>})
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#启动进程</span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#1秒钟之后，立刻结束子进程</span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>terminate()
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>join()
</span></span></code></pre></div><p>注意：进程间不共享全局变量</p>
<p>进程之间的通信-Queue</p>
<p>在初始化Queue()对象时（例如q=Queue(),若在括号中没有指定最大可接受的消息数量，获数量为负值时，那么就代表可接受的消息数量没有上限一直到内存尽头）</p>
<p>Queue.qsize():返回当前队列包含的消息数量</p>
<p>Queue.empty():如果队列为空，返回True，反之False</p>
<p>Queue.full():如果队列满了，返回True,反之False</p>
<p>Queue.get([block[,timeout]]):获取队列中的一条消息，然后将其从队列中移除，</p>
<p>block默认值为True。</p>
<p>如果block使用默认值，且没有设置timeout（单位秒),消息队列如果为空，此时程序将被阻塞（停在读中状态），直到消息队列读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出“Queue.Empty&quot;异常：</p>
<p>Queue.get_nowait()相当于Queue.get(False)</p>
<p>Queue.put(item,[block[,timeout]]):将item消息写入队列，block默认值为True;
如果block使用默认值，且没有设置timeout（单位秒），消息队列如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息队列腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full&quot;异常
如果block值为False，消息队列如果没有空间可写入，则会立刻抛出&quot;Queue.Full&quot;异常;
Queue.put_nowait(item):相当Queue.put(item,False)</p>
<p>进程间通信Demo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process<span style="color:#f92672">.</span>Queue
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os<span style="color:#f92672">,</span>time<span style="color:#f92672">,</span>random
</span></span><span style="display:flex;"><span><span style="color:#75715e">#写数据进程执行的代码：</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">write</span>(q):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> value <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#39;A&#39;</span>,<span style="color:#e6db74">&#39;B&#39;</span>,<span style="color:#e6db74">&#39;C&#39;</span>]:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Put </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> to queue...&#34;</span>,<span style="color:#f92672">%</span>value)
</span></span><span style="display:flex;"><span>        q<span style="color:#f92672">.</span>put(value)
</span></span><span style="display:flex;"><span>        time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>random())
</span></span><span style="display:flex;"><span><span style="color:#75715e">#读数据进程执行的代码</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">read</span>(q):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> q<span style="color:#f92672">.</span>empty():
</span></span><span style="display:flex;"><span>            value <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>get(<span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;Get </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> from queue.&#34;</span>,<span style="color:#f92672">%</span>value)
</span></span><span style="display:flex;"><span>            time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>random())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#父进程创建Queue，并传给各个子进程</span>
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> Queue()
</span></span><span style="display:flex;"><span>    pw <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>write,args<span style="color:#f92672">=</span>(q,))
</span></span><span style="display:flex;"><span>    pr <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>read,args<span style="color:#f92672">=</span>(q,))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#启动子进程pw ，写入：</span>
</span></span><span style="display:flex;"><span>    pw<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#等待pw结束</span>
</span></span><span style="display:flex;"><span>    pw<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#启动子进程pr，读取：</span>
</span></span><span style="display:flex;"><span>    pr<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    pr<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#pr 进程里是死循环，无法等待其结束，只能强行终止:</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;所有数据都写入并且读完&#39;</span>)
</span></span></code></pre></div><pre><code>进程池Pool
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#coding:utf-8</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Pool
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os<span style="color:#f92672">,</span>time<span style="color:#f92672">,</span>random
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">worker</span>(msg):
</span></span><span style="display:flex;"><span>    t_start <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> 开始执行，进程号为</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">%</span>(msg,os<span style="color:#f92672">.</span>getpid()))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># random.random()随机生成0-1之间的浮点数</span>
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>random()<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    t_stop <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
</span></span><span style="display:flex;"><span>    print(msg,<span style="color:#e6db74">&#34;执行完毕，耗时</span><span style="color:#e6db74">%0.2f</span><span style="color:#e6db74">”%（t_stop-t_start))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>po <span style="color:#f92672">=</span> Pool(<span style="color:#ae81ff">3</span>)<span style="color:#75715e">#定义一个进程池，最大进程数3</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">10</span>):
</span></span><span style="display:flex;"><span>    po<span style="color:#f92672">.</span>apply_async(worker,(i,))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;---start----&#34;</span>)
</span></span><span style="display:flex;"><span>po<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>po<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;----end----&#34;</span>)
</span></span></code></pre></div><p>进程池中使用Queue</p>
<p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue(),而不是multiprocessing.Queue(),否则会得到如下的错误信息：</p>
<p>RuntimeError： Queue objects should only be shared between processs through inheritance</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Manager,Pool
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os<span style="color:#f92672">,</span>time<span style="color:#f92672">,</span>random
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reader</span>(q):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;reader 启动(</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">),父进程为（</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">)&#34;</span><span style="color:#f92672">%</span>(os<span style="color:#f92672">.</span>getpid(),os<span style="color:#f92672">.</span>getpid()))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(q<span style="color:#f92672">.</span>qsize()):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;reader 从Queue获取到消息:</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">%</span>q<span style="color:#f92672">.</span>get(<span style="color:#66d9ef">True</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">writer</span>(q):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;writer 启动（</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">),父进程为(</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">)&#34;</span><span style="color:#f92672">%</span>(os<span style="color:#f92672">.</span>getpid(),os<span style="color:#f92672">.</span>getpid()))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> <span style="color:#e6db74">&#34;itcast&#34;</span>:
</span></span><span style="display:flex;"><span>        q<span style="color:#f92672">.</span>put(i)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;(</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">)start&#34;</span><span style="color:#f92672">%</span>os<span style="color:#f92672">.</span>getpid())
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> Manager()<span style="color:#f92672">.</span>Queue()<span style="color:#75715e">#使用Manager中的Queue</span>
</span></span><span style="display:flex;"><span>    po <span style="color:#f92672">=</span> Pool()
</span></span><span style="display:flex;"><span>    po<span style="color:#f92672">.</span>apply_async(wrtier,(q,))
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    po<span style="color:#f92672">.</span>apply_async(reader,(q,))
</span></span><span style="display:flex;"><span>    po<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>    po<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;(</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">)End&#34;</span><span style="color:#f92672">%</span>os<span style="color:#f92672">.</span>getpid())
</span></span></code></pre></div><h3 id="2谈谈你对多进程多线程以及协程的理解项目是否用">2.谈谈你对多进程，多线程，以及协程的理解，项目是否用？<a hidden class="anchor" aria-hidden="true" href="#2谈谈你对多进程多线程以及协程的理解项目是否用">#</a></h3>
<p>这个问题被问的概念相当之大，
进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。</p>
<p>线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程，而多个线程共享内存（数据共享，共享全局变量),从而极大地提高了程序的运行效率。</p>
<p>协程: 是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<h3 id="3python异步使用场景有那些">3.Python异步使用场景有那些？<a hidden class="anchor" aria-hidden="true" href="#3python异步使用场景有那些">#</a></h3>
<p>异步的使用场景:</p>
<p>1、 不涉及共享资源，获对共享资源只读，即非互斥操作</p>
<p>2、 没有时序上的严格关系</p>
<p>3、 不需要原子操作，或可以通过其他方式控制原子性</p>
<p>4、 常用于IO操作等耗时操作，因为比较影响客户体验和使用性能</p>
<p>5、 不影响主线程逻辑</p>
<h3 id="4多线程共同操作同一个数据互斥锁同步">4.多线程共同操作同一个数据互斥锁同步？<a hidden class="anchor" aria-hidden="true" href="#4多线程共同操作同一个数据互斥锁同步">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> threading
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span>(threading<span style="color:#f92672">.</span>Thread):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">global</span> num
</span></span><span style="display:flex;"><span>        time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> mutex<span style="color:#f92672">.</span>acquire(<span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>            num <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            msg <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;set num to &#39;</span> <span style="color:#f92672">+</span>str(num)
</span></span><span style="display:flex;"><span>            print msg
</span></span><span style="display:flex;"><span>            mutex<span style="color:#f92672">.</span>release()
</span></span><span style="display:flex;"><span>num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>mutex <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Lock()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">test</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">5</span>):
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> MyThread()
</span></span><span style="display:flex;"><span>        t<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    test()
</span></span></code></pre></div><h3 id="5什么是多线程竞争">5.什么是多线程竞争？<a hidden class="anchor" aria-hidden="true" href="#5什么是多线程竞争">#</a></h3>
<p>线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即：数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全</p>
<p>那么怎么解决多线程竞争问题？&mdash;锁</p>
<p>锁的好处： 确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。</p>
<p>锁的坏处： 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</p>
<p>锁的致命问题: 死锁</p>
<h3 id="6请介绍一下python的线程同步">6.请介绍一下Python的线程同步？<a hidden class="anchor" aria-hidden="true" href="#6请介绍一下python的线程同步">#</a></h3>
<p>一、 setDaemon(False)
当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，主线程会创建多个子线程，在Python中，默认情况下就是setDaemon(False),主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。</p>
<p>例子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> threading 
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">thread</span>():
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;---子线程结束---&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    t1 <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>thread)
</span></span><span style="display:flex;"><span>    t1<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;---主线程--结束&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    main()
</span></span><span style="display:flex;"><span><span style="color:#75715e">#执行结果</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>主线程<span style="color:#f92672">--</span>结束
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>子线程结束<span style="color:#f92672">---</span>
</span></span></code></pre></div><p>二、 setDaemon（True)
当我们使用setDaemon(True)时，这是子线程为守护线程，主线程一旦执行结束，则全部子线程被强制终止</p>
<p>例子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> threading
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">thread</span>():
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#960050;background-color:#1e0010">’</span><span style="color:#f92672">---</span>子线程结束<span style="color:#f92672">---</span><span style="color:#e6db74">&#39;)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    t1 <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>thread)
</span></span><span style="display:flex;"><span>    t1<span style="color:#f92672">.</span>setDaemon(<span style="color:#66d9ef">True</span>)<span style="color:#75715e">#设置子线程守护主线程</span>
</span></span><span style="display:flex;"><span>    t1<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;---主线程结束---&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    main()
</span></span><span style="display:flex;"><span><span style="color:#75715e">#执行结果</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>主线程结束<span style="color:#f92672">---</span> <span style="color:#75715e">#只有主线程结束，子线程来不及执行就被强制结束</span>
</span></span></code></pre></div><p>三、 join（线程同步)
join 所完成的工作就是线程同步，即主线程任务结束以后，进入堵塞状态，一直等待所有的子线程结束以后，主线程再终止。</p>
<p>当设置守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序，所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和，简单的来说，就是给每个子线程一个timeou的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。</p>
<p>没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。</p>
<p>例子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> threading
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">thread</span>():
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;---子线程结束---&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    t1 <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>thread)
</span></span><span style="display:flex;"><span>    t1<span style="color:#f92672">.</span>setDaemon(<span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>    t1<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    t1<span style="color:#f92672">.</span>join(timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">#1 线程同步，主线程堵塞1s 然后主线程结束，子线程继续执行</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">#2 如果不设置timeout参数就等子线程结束主线程再结束</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">#3 如果设置了setDaemon=True和timeout=1主线程等待1s后会强制杀死子线程，然后主线程结束</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;---主线程结束---&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;__main___&#39;</span>:
</span></span><span style="display:flex;"><span>    main()
</span></span></code></pre></div><h3 id="7解释以下什么是锁有哪几种锁">7.解释以下什么是锁，有哪几种锁？<a hidden class="anchor" aria-hidden="true" href="#7解释以下什么是锁有哪几种锁">#</a></h3>
<p>锁(Lock)是python提供的对线程控制的对象。有互斥锁，可重入锁，死锁。</p>
<h3 id="8什么是死锁">8.什么是死锁？<a hidden class="anchor" aria-hidden="true" href="#8什么是死锁">#</a></h3>
<p>若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。</p>
<p>GIL锁 全局解释器锁</p>
<p>作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！</p>
<p>所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。</p>
<p>进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换</p>
<p>三者的关系：进程里有线程，线程里有协程。</p>
<h3 id="9多线程交互访问数据如果访问到了就不访问了">9.多线程交互访问数据，如果访问到了就不访问了？<a hidden class="anchor" aria-hidden="true" href="#9多线程交互访问数据如果访问到了就不访问了">#</a></h3>
<p>怎么避免重读？</p>
<p>创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。</p>
<h3 id="10什么是线程安全什么是互斥锁">10.什么是线程安全，什么是互斥锁？<a hidden class="anchor" aria-hidden="true" href="#10什么是线程安全什么是互斥锁">#</a></h3>
<p>每个对象都对应于一个可称为’互斥锁‘的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p>
<p>同一进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。</p>
<h3 id="11说说下面几个概念同步异步阻塞非阻塞">11.说说下面几个概念：同步，异步，阻塞，非阻塞？<a hidden class="anchor" aria-hidden="true" href="#11说说下面几个概念同步异步阻塞非阻塞">#</a></h3>
<p>同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。</p>
<p>异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！</p>
<p>阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。</p>
<p>非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。</p>
<p>同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。</p>
<h3 id="12什么是僵尸进程和孤儿进程怎么避免僵尸进程">12.什么是僵尸进程和孤儿进程？怎么避免僵尸进程？<a hidden class="anchor" aria-hidden="true" href="#12什么是僵尸进程和孤儿进程怎么避免僵尸进程">#</a></h3>
<p>孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init 进程（进程号为1）所收养，并由init 进程对他们完成状态收集工作。</p>
<p>僵尸进程： 进程使用fork 创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。</p>
<p>避免僵尸进程的方法：</p>
<p>1.fork 两次用孙子进程去完成子进程的任务</p>
<p>2.用wait()函数使父进程阻塞</p>
<p>3.使用信号量，在signal handler 中调用waitpid,这样父进程不用阻塞</p>
<h3 id="13python中进程与线程的使用场景">13.python中进程与线程的使用场景？<a hidden class="anchor" aria-hidden="true" href="#13python中进程与线程的使用场景">#</a></h3>
<p>多进程适合在CPU密集操作（cpu操作指令比较多，如位多的的浮点运算）。</p>
<p>多线程适合在IO密性型操作（读写数据操作比多的的，比如爬虫）</p>
<h3 id="14线程是并发还是并行进程是并发还是并行">14.线程是并发还是并行，进程是并发还是并行？<a hidden class="anchor" aria-hidden="true" href="#14线程是并发还是并行进程是并发还是并行">#</a></h3>
<p>线程是并发，进程是并行;</p>
<p>进程之间互相独立，是系统分配资源的最小单位，同一个进程中的所有线程共享资源。</p>
<h3 id="15并行parallel和并发concurrency">15.并行(parallel)和并发（concurrency)?<a hidden class="anchor" aria-hidden="true" href="#15并行parallel和并发concurrency">#</a></h3>
<p>并行： 同一时刻多个任务同时在运行</p>
<p>并发：不会在同一时刻同时运行，存在交替执行的情况。</p>
<p>实现并行的库有： multiprocessing</p>
<p>实现并发的库有:  threading</p>
<p>程序需要执行较多的读写、请求和回复任务的需要大量的IO操作，IO密集型操作使用并发更好。</p>
<p>CPU运算量大的程序，使用并行会更好</p>
<h3 id="16io密集型和cpu密集型区别">16.IO密集型和CPU密集型区别？<a hidden class="anchor" aria-hidden="true" href="#16io密集型和cpu密集型区别">#</a></h3>
<p>IO密集型： 系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写</p>
<p>CPU密集型： 大部分时间用来做计算，逻辑判断等CPU动作的程序称之CPU密集型。</p>
<h3 id="17python-asyncio的原理">17.python asyncio的原理？<a hidden class="anchor" aria-hidden="true" href="#17python-asyncio的原理">#</a></h3>
<p>asyncio这个库就是使用python的yield这个可以打断保存当前函数的上下文的机制， 封装好了selector 摆脱掉了复杂的回调关系</p>
<h2 id="网络编程">网络编程<a hidden class="anchor" aria-hidden="true" href="#网络编程">#</a></h2>
<h3 id="1怎么实现强行关闭客户端和服务器之间的连接">1.怎么实现强行关闭客户端和服务器之间的连接?<a hidden class="anchor" aria-hidden="true" href="#1怎么实现强行关闭客户端和服务器之间的连接">#</a></h3>
<h3 id="2简述tcp和udp的区别以及优缺点">2.简述TCP和UDP的区别以及优缺点?<a hidden class="anchor" aria-hidden="true" href="#2简述tcp和udp的区别以及优缺点">#</a></h3>
<h3 id="3简述浏览器通过wsgi请求动态资源的过程">3.简述浏览器通过WSGI请求动态资源的过程?<a hidden class="anchor" aria-hidden="true" href="#3简述浏览器通过wsgi请求动态资源的过程">#</a></h3>
<p>浏览器发送的请求被Nginx监听到，Nginx根据请求的URL的PATH或者后缀把请求静态资源的分发到静态资源的目录，别的请求根据配置好的转发到相应端口。
实现了WSGI的程序会监听某个端口，监听到Nginx转发过来的请求接收后(一般用socket的recv来接收HTTP的报文)以后把请求的报文封装成<code>environ</code>的字典对象，然后再提供一个<code>start_response</code>的方法。把这两个对象当成参数传入某个方法比如<code>wsgi_app(environ, start_response)</code>或者实现了<code>__call__(self, environ, start_response)</code>方法的某个实例。这个实例再调用<code>start_response</code>返回给实现了WSGI的中间件，再由中间件返回给Nginx。</p>
<h3 id="4描述用浏览器访问wwwbaiducom的过程">4.描述用浏览器访问www.baidu.com的过程<a hidden class="anchor" aria-hidden="true" href="#4描述用浏览器访问wwwbaiducom的过程">#</a></h3>
<h3 id="5post和get请求的区别">5.Post和Get请求的区别?<a hidden class="anchor" aria-hidden="true" href="#5post和get请求的区别">#</a></h3>
<h3 id="6cookie-和session-的区别">6.cookie 和session 的区别？<a hidden class="anchor" aria-hidden="true" href="#6cookie-和session-的区别">#</a></h3>
<h3 id="7列出你知道的http协议的状态码说出表示什么意思">7.列出你知道的HTTP协议的状态码，说出表示什么意思？<a hidden class="anchor" aria-hidden="true" href="#7列出你知道的http协议的状态码说出表示什么意思">#</a></h3>
<h3 id="8请简单说一下三次握手和四次挥手">8.请简单说一下三次握手和四次挥手？<a hidden class="anchor" aria-hidden="true" href="#8请简单说一下三次握手和四次挥手">#</a></h3>
<h3 id="9说一下什么是tcp的2msl">9.说一下什么是tcp的2MSL？<a hidden class="anchor" aria-hidden="true" href="#9说一下什么是tcp的2msl">#</a></h3>
<h3 id="10为什么客户端在time-wait状态必须等待2msl的时间">10.为什么客户端在TIME-WAIT状态必须等待2MSL的时间？<a hidden class="anchor" aria-hidden="true" href="#10为什么客户端在time-wait状态必须等待2msl的时间">#</a></h3>
<h3 id="11说说http和https区别">11.说说HTTP和HTTPS区别？<a hidden class="anchor" aria-hidden="true" href="#11说说http和https区别">#</a></h3>
<h3 id="12谈一下http协议以及协议头部中表示数据类型的字段">12.谈一下HTTP协议以及协议头部中表示数据类型的字段？<a hidden class="anchor" aria-hidden="true" href="#12谈一下http协议以及协议头部中表示数据类型的字段">#</a></h3>
<h3 id="13http请求方法都有什么">13.HTTP请求方法都有什么？<a hidden class="anchor" aria-hidden="true" href="#13http请求方法都有什么">#</a></h3>
<h3 id="14使用socket套接字需要传入哪些参数-">14.使用Socket套接字需要传入哪些参数 ？<a hidden class="anchor" aria-hidden="true" href="#14使用socket套接字需要传入哪些参数-">#</a></h3>
<h3 id="15http常见请求头">15.HTTP常见请求头？<a hidden class="anchor" aria-hidden="true" href="#15http常见请求头">#</a></h3>
<h3 id="16七层模型">16.七层模型？<a hidden class="anchor" aria-hidden="true" href="#16七层模型">#</a></h3>
<h3 id="17url的形式">17.url的形式？<a hidden class="anchor" aria-hidden="true" href="#17url的形式">#</a></h3>
<h1 id="web">Web<a hidden class="anchor" aria-hidden="true" href="#web">#</a></h1>
<h2 id="flask">Flask<a hidden class="anchor" aria-hidden="true" href="#flask">#</a></h2>
<h3 id="1对flask蓝图blueprint的理解">1.对Flask蓝图(Blueprint)的理解？<a hidden class="anchor" aria-hidden="true" href="#1对flask蓝图blueprint的理解">#</a></h3>
<p>蓝图的定义</p>
<p>蓝图 /Blueprint 是Flask应用程序组件化的方法，可以在一个应用内或跨越多个项目共用蓝图。使用蓝图可以极大简化大型应用的开发难度，也为Flask扩展提供了一种在应用中注册服务的集中式机制。</p>
<p>蓝图的应用场景：</p>
<p>把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。</p>
<p>以URL前缀和/或子域名，在应用上注册一个蓝图。URL前缀/子域名中的参数即成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下）
在一个应用中用不同的URL规则多次注册一个蓝图。</p>
<p>通过蓝图提供模板过滤器、静态文件、模板和其他功能。一个蓝图不一定要实现应用或视图函数。</p>
<p>初始化一个Flask扩展时，在这些情况中注册一个蓝图。</p>
<p>蓝图的缺点：</p>
<p>不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。</p>
<p>使用蓝图的三个步骤</p>
<p>1.创建一个蓝图对象</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>blue <span style="color:#f92672">=</span> Blueprint(<span style="color:#e6db74">&#34;blue&#34;</span>,__name__)
</span></span></code></pre></div><p>2.在这个蓝图对象上进行操作，例如注册路由、指定静态文件夹、注册模板过滤器&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a6e22e">@blue.route</span>(<span style="color:#e6db74">&#39;/&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">blue_index</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Welcome to my blueprint&#34;</span>
</span></span></code></pre></div><p>3.在应用对象上注册这个蓝图对象</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>app<span style="color:#f92672">.</span>register_blueprint(blue,url_prefix<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/blue&#34;</span>)
</span></span></code></pre></div><h3 id="2flask-和-django-路由映射的区别">2.Flask 和 Django 路由映射的区别？<a hidden class="anchor" aria-hidden="true" href="#2flask-和-django-路由映射的区别">#</a></h3>
<p>在django中，路由是浏览器访问服务器时，先访问的项目中的url，再由项目中的url找到应用中url，这些url是放在一个列表里，遵从从前往后匹配的规则。在flask中，路由是通过装饰器给每个视图函数提供的，而且根据请求方式的不同可以一个url用于不同的作用。</p>
<h2 id="django">Django<a hidden class="anchor" aria-hidden="true" href="#django">#</a></h2>
<h3 id="1什么是wsgiuwsgiuwsgi">1.什么是wsgi,uwsgi,uWSGI?<a hidden class="anchor" aria-hidden="true" href="#1什么是wsgiuwsgiuwsgi">#</a></h3>
<p>WSGI:</p>
<p>web服务器网关接口，是一套协议。用于接收用户请求并将请求进行初次封装，然后将请求交给web框架。</p>
<p>实现wsgi协议的模块：wsgiref,本质上就是编写一socket服务端，用于接收用户请求（django)</p>
<p>werkzeug,本质上就是编写一个socket服务端，用于接收用户请求(flask)</p>
<p>uwsgi:</p>
<p>与WSGI一样是一种通信协议，它是uWSGI服务器的独占协议，用于定义传输信息的类型。
uWSGI:</p>
<p>是一个web服务器，实现了WSGI的协议，uWSGI协议，http协议</p>
<h3 id="2djangoflasktornado的对比">2.Django、Flask、Tornado的对比？<a hidden class="anchor" aria-hidden="true" href="#2djangoflasktornado的对比">#</a></h3>
<p>1、 Django走的大而全的方向，开发效率高。它的MTV框架，自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器，给开发者提高了超高的开发效率。
重量级web框架，功能齐全，提供一站式解决的思路，能让开发者不用在选择上花费大量时间。</p>
<p>自带ORM和模板引擎，支持jinja等非官方模板引擎。</p>
<p>自带ORM使Django和关系型数据库耦合度高，如果要使用非关系型数据库，需要使用第三方库</p>
<p>自带数据库管理app</p>
<p>成熟，稳定，开发效率高，相对于Flask，Django的整体封闭性比较好，适合做企业级网站的开发。python web框架的先驱，第三方库丰富</p>
<p>2、 Flask 是轻量级的框架，自由，灵活，可扩展性强，核心基于Werkzeug WSGI工具 和jinja2 模板引擎</p>
<p>适用于做小网站以及web服务的API,开发大型网站无压力，但架构需要自己设计</p>
<p>与关系型数据库的结合不弱于Django，而与非关系型数据库的结合远远优于Django</p>
<p>3、 Tornado走的是少而精的方向，性能优越，它最出名的异步非阻塞的设计方式</p>
<p>Tornado的两大核心模块：</p>
<p>iostraem:对非阻塞的socket进行简单的封装</p>
<p>ioloop: 对I/O 多路复用的封装,它实现一个单例</p>
<h3 id="3cors-和-csrf的区别">3.CORS 和 CSRF的区别？<a hidden class="anchor" aria-hidden="true" href="#3cors-和-csrf的区别">#</a></h3>
<p>什么是CORS？</p>
<p>CORS是一个W3C标准,全称是“跨域资源共享&quot;(Cross-origin resoure sharing).
它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
<p>什么是CSRF？</p>
<p>CSRF主流防御方式是在后端生成表单的时候生成一串随机token,内置到表单里成为一个字段，同时，将此串token置入session中。每次表单提交到后端时都会检查这两个值是否一致，以此来判断此次表单提交是否是可信的，提交过一次之后，如果这个页面没有生成CSRF token,那么token将会被清空,如果有新的需求，那么token会被更新。
攻击者可以伪造POST表单提交，但是他没有后端生成的内置于表单的token，session中没有token都无济于事。</p>
<h3 id="4sessioncookiejwt的理解">4.Session,Cookie,JWT的理解<a hidden class="anchor" aria-hidden="true" href="#4sessioncookiejwt的理解">#</a></h3>
<p>为什么要使用会话管理</p>
<p>众所周知，HTTP协议是一个无状态的协议，也就是说每个请求都是一个独立的请求，请求与请求之间并无关系。但在实际的应用场景，这种方式并不能满足我们的需求。举个大家都喜欢用的例子，把商品加入购物车，单独考虑这个请求，服务端并不知道这个商品是谁的，应该加入谁的购物车？因此这个请求的上下文环境实际上应该包含用户的相关信息，在每次用户发出请求时把这一小部分额外信息，也做为请求的一部分，这样服务端就可以根据上下文中的信息，针对具体的用户进行操作。所以这几种技术的出现都是对HTTP协议的一个补充，使得我们可以用HTTP协议+状态管理构建一个的面向用户的WEB应用。</p>
<p>Session 和Cookie的区别</p>
<p>这里我想先谈谈session与cookies,因为这两个技术是做为开发最为常见的。那么session与cookies的区别是什么？个人认为session与cookies最核心区别在于额外信息由谁来维护。利用cookies来实现会话管理时，用户的相关信息或者其他我们想要保持在每个请求中的信息，都是放在cookies中,而cookies是由客户端来保存，每当客户端发出新请求时，就会稍带上cookies,服务端会根据其中的信息进行操作。
当利用session来进行会话管理时，客户端实际上只存了一个由服务端发送的session_id,而由这个session_id,可以在服务端还原出所需要的所有状态信息，从这里可以看出这部分信息是由服务端来维护的。</p>
<p>除此以外，session与cookies都有一些自己的缺点：</p>
<p>cookies的安全性不好，攻击者可以通过获取本地cookies进行欺骗或者利用cookies进行CSRF攻击。使用cookies时,在多个域名下，会存在跨域问题。
session 在一定的时间里，需要存放在服务端，因此当拥有大量用户时，也会大幅度降低服务端的性能，当有多台机器时，如何共享session也会是一个问题.(redis集群)也就是说，用户第一个访问的时候是服务器A，而第二个请求被转发给了服务器B，那服务器B如何得知其状态。实际上，session与cookies是有联系的，比如我们可以把session_id存放在cookies中的。</p>
<p>JWT是如何工作的</p>
<p>首先用户发出登录请求，服务端根据用户的登录请求进行匹配，如果匹配成功，将相关的信息放入payload中，利用算法，加上服务端的密钥生成token，这里需要注意的是secret_key很重要，如果这个泄露的话，客户端就可以随机篡改发送的额外信息，它是信息完整性的保证。生成token后服务端将其返回给客户端，客户端可以在下次请求时，将token一起交给服务端，一般是说我们可以将其放在Authorization首部中，这样也就可以避免跨域问题。</p>
<h3 id="5简述django请求生命周期">5.简述Django请求生命周期<a hidden class="anchor" aria-hidden="true" href="#5简述django请求生命周期">#</a></h3>
<p>一般是用户通过浏览器向我们的服务器发起一个请求(request),这个请求会去访问视图函数，如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户）
视图函数调用模型毛模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。</p>
<p>1.wsgi ,请求封装后交给web框架（Flask，Django)</p>
<p>2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf,request.session</p>
<p>3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数</p>
<p>4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm，templates</p>
<p>5.中间件，对响应的数据进行处理</p>
<p>6.wsgi，将响应的内容发送给浏览器</p>
<h3 id="6用的restframework完成api发送时间时区">6.用的restframework完成api发送时间时区<a hidden class="anchor" aria-hidden="true" href="#6用的restframework完成api发送时间时区">#</a></h3>
<p>当前的问题是用django的rest framework模块做一个get请求的发送时间以及时区信息的api</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">getCurrenttime</span>(APIView):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get</span>(self,request):
</span></span><span style="display:flex;"><span>        local_time <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>localtime()
</span></span><span style="display:flex;"><span>        time_zone <span style="color:#f92672">=</span>settings<span style="color:#f92672">.</span>TIME_ZONE
</span></span><span style="display:flex;"><span>        temp <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;localtime&#39;</span>:local_time,<span style="color:#e6db74">&#39;timezone&#39;</span>:time_zone}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Response(temp)
</span></span></code></pre></div><h3 id="7nginxtomcatapach到都是什么">7.nginx,tomcat,apach到都是什么？<a hidden class="anchor" aria-hidden="true" href="#7nginxtomcatapach到都是什么">#</a></h3>
<p>Nginx（engine x)是一个高性能的HTTP和反向代理服务器，也是 一个IMAP/POP3/SMTP服务器，工作在OSI七层，负载的实现方式：轮询，IP_HASH,fair,session_sticky.
Apache HTTP Server是一个模块化的服务器，源于NCSAhttpd服务器
Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，是开发和调试JSP程序的首选。</p>
<h3 id="8请给出你熟悉关系数据库范式有哪些有什么作用">8.请给出你熟悉关系数据库范式有哪些，有什么作用？<a hidden class="anchor" aria-hidden="true" href="#8请给出你熟悉关系数据库范式有哪些有什么作用">#</a></h3>
<p>在进行数据库的设计时，所遵循的一些规范，只要按照设计规范进行设计，就能设计出没有数据冗余和数据维护异常的数据库结构。</p>
<p>数据库的设计的规范有很多，通常来说我们在设是数据库时只要达到其中一些规范就可以了，这些规范又称之为数据库的三范式，一共有三条，也存在着其他范式，我们只要做到满足前三个范式的要求，就能设陈出符合我们的数据库了，我们也不能全部来按照范式的要求来做，还要考虑实际的业务使用情况，所以有时候也需要做一些违反范式的要求。
1.数据库设计的第一范式(最基本)，基本上所有数据库的范式都是符合第一范式的，符合第一范式的表具有以下几个特点：</p>
<p>数据库表中的所有字段都只具有单一属性，单一属性的列是由基本的数据类型（整型，浮点型，字符型等）所构成的设计出来的表都是简单的二比表</p>
<p>2.数据库设计的第二范式(是在第一范式的基础上设计的)，要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系</p>
<p>3.数据库设计的第三范式，指每一个非主属性既不部分依赖与也不传递依赖于业务主键，也就是第二范式的基础上消除了非主属性对主键的传递依赖</p>
<h3 id="9简述qq登陆过程">9.简述QQ登陆过程<a hidden class="anchor" aria-hidden="true" href="#9简述qq登陆过程">#</a></h3>
<p>qq登录，在我们的项目中分为了三个接口，</p>
<p>第一个接口是请求qq服务器返回一个qq登录的界面;</p>
<p>第二个接口是通过扫码或账号登陆进行验证，qq服务器返回给浏览器一个code和state,利用这个code通过本地服务器去向qq服务器获取access_token覆返回给本地服务器，凭借access_token再向qq服务器获取用户的openid(openid用户的唯一标识)</p>
<p>第三个接口是判断用户是否是第一次qq登录，如果不是的话直接登录返回的jwt-token给用户，对没有绑定过本网站的用户，对openid进行加密生成token进行绑定</p>
<h3 id="10post-和-get的区别">10.post 和 get的区别?<a hidden class="anchor" aria-hidden="true" href="#10post-和-get的区别">#</a></h3>
<p>1.GET是从服务器上获取数据，POST是向服务器传送数据</p>
<p>2.在客户端，GET方式在通过URL提交数据，数据在URL中可以看到，POST方式，数据放置在HTML——HEADER内提交</p>
<p>3.对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据</p>
<h3 id="11项目中日志的作用">11.项目中日志的作用<a hidden class="anchor" aria-hidden="true" href="#11项目中日志的作用">#</a></h3>
<p>一、日志相关概念</p>
<p>1.日志是一种可以追踪某些软件运行时所发生事件的方法</p>
<p>2.软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情</p>
<p>3.一个事件可以用一个包含可选变量数据的消息来描述</p>
<p>4.此外，事件也有重要性的概念，这个重要性也可以被成为严重性级别(level)</p>
<p>二、日志的作用</p>
<p>1.通过log的分析，可以方便用户了解系统或软件、应用的运行情况;</p>
<p>2.如果你的应用log足够丰富，可以分析以往用户的操作行为、类型喜好，地域分布或其他更多信息;</p>
<p>3.如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。</p>
<p>4.简单来讲就是我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时快速定位问题。不仅在开发中，在运维中日志也很重要，日志的作用也可以简单。总结为以下几点：</p>
<p>1.程序调试</p>
<p>2.了解软件程序运行情况，是否正常</p>
<p>3,软件程序运行故障分析与问题定位</p>
<p>4,如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析</p>
<h3 id="12django中间件的使用">12.django中间件的使用？<a hidden class="anchor" aria-hidden="true" href="#12django中间件的使用">#</a></h3>
<p>Django在中间件中预置了六个方法，这六个方法的区别在于不同的阶段执行，对输入或输出进行干预，方法如下：</p>
<p>1.初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> __init__():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><p>2.处理请求前：在每个请求上调用，返回None或HttpResponse对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">process_request</span>(request):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><p>3.处理视图前:在每个请求上调用，返回None或HttpResponse对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">process_view</span>(request,view_func,view_args,view_kwargs):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><p>4.处理模板响应前：在每个请求上调用，返回实现了render方法的响应对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">process_template_response</span>(request,response):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><p>5.处理响应后：所有响应返回浏览器之前被调用，在每个请求上调用，返回HttpResponse对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">process_response</span>(request,response):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><p>6.异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个HttpResponse对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">process_exception</span>(request,exception):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><h3 id="13谈一下你对uwsgi和nginx的理解">13.谈一下你对uWSGI和nginx的理解？<a hidden class="anchor" aria-hidden="true" href="#13谈一下你对uwsgi和nginx的理解">#</a></h3>
<p>1.uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。WSGI是一种Web服务器网关接口。它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如用Flask框架写的程序）通信的一种规范。</p>
<p>要注意WSGI/uwsgi/uWSGI这三个概念的区分。</p>
<p>WSGI是一种通信协议。</p>
<p>uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。</p>
<p>uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。</p>
<p>nginx 是一个开源的高性能的HTTP服务器和反向代理：</p>
<p>1.作为web服务器，它处理静态文件和索引文件效果非常高</p>
<p>2.它的设计非常注重效率，最大支持5万个并发连接，但只占用很少的内存空间</p>
<p>3.稳定性高，配置简洁。</p>
<p>4.强大的反向代理和负载均衡功能，平衡集群中各个服务器的负载压力应用</p>
<h3 id="14python中三大框架各自的应用场景">14.Python中三大框架各自的应用场景？<a hidden class="anchor" aria-hidden="true" href="#14python中三大框架各自的应用场景">#</a></h3>
<p>django:主要是用来搞快速开发的，他的亮点就是快速开发，节约成本，,如果要实现高并发的话，就要对django进行二次开发，比如把整个笨重的框架给拆掉自己写socket实现http的通信,底层用纯c,c++写提升效率，ORM框架给干掉，自己编写封装与数据库交互的框架,ORM虽然面向对象来操作数据库，但是它的效率很低，使用外键来联系表与表之间的查询;
flask: 轻量级，主要是用来写接口的一个框架，实现前后端分离，提考开发效率，Flask本身相当于一个内核，其他几乎所有的功能都要用到扩展(邮件扩展Flask-Mail，用户认证Flask-Login),都需要用第三方的扩展来实现。比如可以用Flask-extension加入ORM、文件上传、身份验证等。Flask没有默认使用的数据库，你可以选择MySQL，也可以用NoSQL。</p>
<p>其WSGI工具箱用Werkzeug(路由模块)，模板引擎则使用Jinja2,这两个也是Flask框架的核心。</p>
<p>Tornado： Tornado是一种Web服务器软件的开源版本。Tornado和现在的主流Web服务器框架（包括大多数Python的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其非阻塞的方式和对epoll的运用，Tornado每秒可以处理数以千计的连接因此Tornado是实时Web服务的一个理想框架</p>
<h3 id="15django中哪里用到了线程哪里用到了协程哪里用到了进程">15.Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？<a hidden class="anchor" aria-hidden="true" href="#15django中哪里用到了线程哪里用到了协程哪里用到了进程">#</a></h3>
<p>1.Django中耗时的任务用一个进程或者线程来执行，比如发邮件，使用celery.</p>
<p>2.部署django项目是时候，配置文件中设置了进程和协程的相关配置。</p>
<h3 id="16有用过django-rest-framework吗">16.有用过Django REST framework吗？<a hidden class="anchor" aria-hidden="true" href="#16有用过django-rest-framework吗">#</a></h3>
<p>Django REST framework是一个强大而灵活的Web API工具。使用RESTframework的理由有：</p>
<p>Web browsable API对开发者有极大的好处</p>
<p>包括OAuth1a和OAuth2的认证策略</p>
<p>支持ORM和非ORM数据资源的序列化</p>
<p>全程自定义开发&ndash;如果不想使用更加强大的功能，可仅仅使用常规的function-based views额外的文档和强大的社区支持</p>
<h3 id="17对cookies与session的了解他们能单独用吗">17.对cookies与session的了解？他们能单独用吗？<a hidden class="anchor" aria-hidden="true" href="#17对cookies与session的了解他们能单独用吗">#</a></h3>
<p>Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但是禁用Cookie就不能得到Session。因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于SessionID,也就得不到Session。</p>
<h2 id="爬虫">爬虫<a hidden class="anchor" aria-hidden="true" href="#爬虫">#</a></h2>
<h3 id="1试列出至少三种目前流行的大型数据库">1.试列出至少三种目前流行的大型数据库<a hidden class="anchor" aria-hidden="true" href="#1试列出至少三种目前流行的大型数据库">#</a></h3>
<h3 id="2列举您使用过的python网络爬虫所用到的网络数据包">2.列举您使用过的Python网络爬虫所用到的网络数据包?<a hidden class="anchor" aria-hidden="true" href="#2列举您使用过的python网络爬虫所用到的网络数据包">#</a></h3>
<p>requests, urllib,urllib2, httplib2</p>
<h3 id="3爬取数据后使用哪个数据库存储数据的为什么">3.爬取数据后使用哪个数据库存储数据的，为什么？<a hidden class="anchor" aria-hidden="true" href="#3爬取数据后使用哪个数据库存储数据的为什么">#</a></h3>
<h3 id="4你用过的爬虫框架或者模块有哪些优缺点">4.你用过的爬虫框架或者模块有哪些？优缺点？<a hidden class="anchor" aria-hidden="true" href="#4你用过的爬虫框架或者模块有哪些优缺点">#</a></h3>
<p>Python自带：urllib,urllib2</p>
<p>第三方：requests</p>
<p>框架： Scrapy</p>
<p>urllib 和urllib2模块都做与请求URL相关的操作，但他们提供不同的功能。</p>
<p>urllib2: urllib2.urlopen可以接受一个Request对象或者url,(在接受Request对象时，并以此可以来设置一个URL的headers),urllib.urlopen只接收一个url。</p>
<p>urllib 有urlencode,urllib2没有，因此总是urllib, urllib2常会一起使用的原因</p>
<p>scrapy是封装起来的框架，他包含了下载器，解析器，日志及异常处理，基于多线程，twisted的方式处理，对于固定单个网站的爬取开发，有优势，但是对于多网站爬取100个网站，并发及分布式处理不够灵活，不便调整与扩展</p>
<p>requests是一个HTTP库，它只是用来请求，它是一个强大的库，下载，解析全部自己处理，灵活性高</p>
<p>Scrapy优点：异步，xpath，强大的统计和log系统，支持不同url。shell方便独立调试。写middleware方便过滤。通过管道存入数据库</p>
<h3 id="5写爬虫是用多进程好还是多线程好">5.写爬虫是用多进程好？还是多线程好？<a hidden class="anchor" aria-hidden="true" href="#5写爬虫是用多进程好还是多线程好">#</a></h3>
<h3 id="6常见的反爬虫和应对方法">6.常见的反爬虫和应对方法？<a hidden class="anchor" aria-hidden="true" href="#6常见的反爬虫和应对方法">#</a></h3>
<h3 id="7解析网页的解析器使用最多的是哪几个">7.解析网页的解析器使用最多的是哪几个?<a hidden class="anchor" aria-hidden="true" href="#7解析网页的解析器使用最多的是哪几个">#</a></h3>
<h3 id="8需要登录的网页如何解决同时限制ipcookiesession">8.需要登录的网页，如何解决同时限制ip，cookie,session<a hidden class="anchor" aria-hidden="true" href="#8需要登录的网页如何解决同时限制ipcookiesession">#</a></h3>
<h3 id="9验证码的解决">9.验证码的解决?<a hidden class="anchor" aria-hidden="true" href="#9验证码的解决">#</a></h3>
<h3 id="10使用最多的数据库对他们的理解">10.使用最多的数据库，对他们的理解？<a hidden class="anchor" aria-hidden="true" href="#10使用最多的数据库对他们的理解">#</a></h3>
<h3 id="11编写过哪些爬虫中间件">11.编写过哪些爬虫中间件？<a hidden class="anchor" aria-hidden="true" href="#11编写过哪些爬虫中间件">#</a></h3>
<h3 id="12极验滑动验证码如何破解">12.“极验”滑动验证码如何破解？<a hidden class="anchor" aria-hidden="true" href="#12极验滑动验证码如何破解">#</a></h3>
<h3 id="13爬虫多久爬一次爬下来的数据是怎么存储">13.爬虫多久爬一次，爬下来的数据是怎么存储？<a hidden class="anchor" aria-hidden="true" href="#13爬虫多久爬一次爬下来的数据是怎么存储">#</a></h3>
<h3 id="14cookie过期的处理问题">14.cookie过期的处理问题？<a hidden class="anchor" aria-hidden="true" href="#14cookie过期的处理问题">#</a></h3>
<h3 id="15动态加载又对及时性要求很高怎么处理">15.动态加载又对及时性要求很高怎么处理？<a hidden class="anchor" aria-hidden="true" href="#15动态加载又对及时性要求很高怎么处理">#</a></h3>
<h3 id="16https有什么优点和缺点">16.HTTPS有什么优点和缺点？<a hidden class="anchor" aria-hidden="true" href="#16https有什么优点和缺点">#</a></h3>
<h3 id="17https是如何实现安全传输数据的">17.HTTPS是如何实现安全传输数据的？<a hidden class="anchor" aria-hidden="true" href="#17https是如何实现安全传输数据的">#</a></h3>
<h3 id="18ttlmslrtt各是什么">18.TTL，MSL，RTT各是什么？<a hidden class="anchor" aria-hidden="true" href="#18ttlmslrtt各是什么">#</a></h3>
<h3 id="19谈一谈你对selenium和phantomjs了解">19.谈一谈你对Selenium和PhantomJS了解<a hidden class="anchor" aria-hidden="true" href="#19谈一谈你对selenium和phantomjs了解">#</a></h3>
<h3 id="20平常怎么使用代理的-">20.平常怎么使用代理的 ？<a hidden class="anchor" aria-hidden="true" href="#20平常怎么使用代理的-">#</a></h3>
<h3 id="21存放在数据库redismysql等">21.存放在数据库(redis、mysql等)。<a hidden class="anchor" aria-hidden="true" href="#21存放在数据库redismysql等">#</a></h3>
<h3 id="22怎么监控爬虫的状态">22.怎么监控爬虫的状态?<a hidden class="anchor" aria-hidden="true" href="#22怎么监控爬虫的状态">#</a></h3>
<h3 id="23描述下scrapy框架运行的机制">23.描述下scrapy框架运行的机制？<a hidden class="anchor" aria-hidden="true" href="#23描述下scrapy框架运行的机制">#</a></h3>
<h3 id="24谈谈你对scrapy的理解">24.谈谈你对Scrapy的理解？<a hidden class="anchor" aria-hidden="true" href="#24谈谈你对scrapy的理解">#</a></h3>
<h3 id="25怎么样让-scrapy-框架发送一个-post-请求具体写出来">25.怎么样让 scrapy 框架发送一个 post 请求（具体写出来）<a hidden class="anchor" aria-hidden="true" href="#25怎么样让-scrapy-框架发送一个-post-请求具体写出来">#</a></h3>
<h3 id="26怎么监控爬虫的状态-">26.怎么监控爬虫的状态 ？<a hidden class="anchor" aria-hidden="true" href="#26怎么监控爬虫的状态-">#</a></h3>
<h3 id="27怎么判断网站是否更新">27.怎么判断网站是否更新？<a hidden class="anchor" aria-hidden="true" href="#27怎么判断网站是否更新">#</a></h3>
<h3 id="28图片视频爬取怎么绕过防盗连接">28.图片、视频爬取怎么绕过防盗连接<a hidden class="anchor" aria-hidden="true" href="#28图片视频爬取怎么绕过防盗连接">#</a></h3>
<h3 id="29你爬出来的数据量大概有多大大概多长时间爬一次">29.你爬出来的数据量大概有多大？大概多长时间爬一次？<a hidden class="anchor" aria-hidden="true" href="#29你爬出来的数据量大概有多大大概多长时间爬一次">#</a></h3>
<h3 id="30用什么数据库存爬下来的数据部署是你做的吗怎么部署">30.用什么数据库存爬下来的数据？部署是你做的吗？怎么部署？<a hidden class="anchor" aria-hidden="true" href="#30用什么数据库存爬下来的数据部署是你做的吗怎么部署">#</a></h3>
<h3 id="31增量爬取">31.增量爬取<a hidden class="anchor" aria-hidden="true" href="#31增量爬取">#</a></h3>
<h3 id="32爬取下来的数据如何去重说一下scrapy的具体的算法依据">32.爬取下来的数据如何去重，说一下scrapy的具体的算法依据。<a hidden class="anchor" aria-hidden="true" href="#32爬取下来的数据如何去重说一下scrapy的具体的算法依据">#</a></h3>
<h3 id="33scrapy的优缺点">33.Scrapy的优缺点?<a hidden class="anchor" aria-hidden="true" href="#33scrapy的优缺点">#</a></h3>
<h3 id="34怎么设置爬取深度">34.怎么设置爬取深度？<a hidden class="anchor" aria-hidden="true" href="#34怎么设置爬取深度">#</a></h3>
<h3 id="35scrapy和scrapy-redis有什么区别为什么选择redis数据库">35.scrapy和scrapy-redis有什么区别？为什么选择redis数据库？<a hidden class="anchor" aria-hidden="true" href="#35scrapy和scrapy-redis有什么区别为什么选择redis数据库">#</a></h3>
<h3 id="36分布式爬虫主要解决什么问题">36.分布式爬虫主要解决什么问题？<a hidden class="anchor" aria-hidden="true" href="#36分布式爬虫主要解决什么问题">#</a></h3>
<h3 id="37什么是分布式存储">37.什么是分布式存储？<a hidden class="anchor" aria-hidden="true" href="#37什么是分布式存储">#</a></h3>
<h3 id="38你所知道的分布式爬虫方案有哪些">38.你所知道的分布式爬虫方案有哪些？<a hidden class="anchor" aria-hidden="true" href="#38你所知道的分布式爬虫方案有哪些">#</a></h3>
<h3 id="39scrapy-redis有做过其他的分布式爬虫吗">39.scrapy-redis，有做过其他的分布式爬虫吗？<a hidden class="anchor" aria-hidden="true" href="#39scrapy-redis有做过其他的分布式爬虫吗">#</a></h3>
<h1 id="数据库">数据库<a hidden class="anchor" aria-hidden="true" href="#数据库">#</a></h1>
<h2 id="mysql">MySQL<a hidden class="anchor" aria-hidden="true" href="#mysql">#</a></h2>
<h3 id="1主键-超键-候选键-外键">1.主键 超键 候选键 外键<a hidden class="anchor" aria-hidden="true" href="#1主键-超键-候选键-外键">#</a></h3>
<p>主键：数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值(Null).</p>
<p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<p>候选键：是最小超键，即没有冗余元素的超键。</p>
<p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>
<h3 id="2视图的作用视图可以更改么">2.视图的作用，视图可以更改么？<a hidden class="anchor" aria-hidden="true" href="#2视图的作用视图可以更改么">#</a></h3>
<p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询;不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据;视图创建后，可以使用与表相同的方式利用它们。</p>
<p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖。</p>
<p>创建视图： create view xxx as xxxxxx</p>
<p>对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新;但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</p>
<h3 id="3dropdelete与truncate的区别">3.drop,delete与truncate的区别<a hidden class="anchor" aria-hidden="true" href="#3dropdelete与truncate的区别">#</a></h3>
<p>drop直接删掉表，truncate删除表中数据，再插入时自增长id又从1开始，delete删除表中数据，可以加where字句。</p>
<p>1.delete 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。truncate table则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器，执行速度快。</p>
<p>2.表和索引所占空间。当表被truncate后，这个表和索引所占用的空间会恢复到初始大小，而delete操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p>
<p>3.一般而言，drop&gt;truncate&gt;delete</p>
<p>4.应用范围。truncate只能对table，delete可以是table和view</p>
<p>5.truncate和delete只删除数据，而drop则删除整个表（结构和数据)</p>
<p>6.truncate与不带where的delete:只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束(constrain),触发器（trigger)索引(index);依赖于该表的存储过程/函数将被保留，但其状态会变为:invalid.</p>
<h3 id="4索引的工作原理及其种类">4.索引的工作原理及其种类<a hidden class="anchor" aria-hidden="true" href="#4索引的工作原理及其种类">#</a></h3>
<p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引的实现通常使用B树以其变种B+树。</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间（因为索引也要随之变动）</p>
<h3 id="5连接的种类">5.连接的种类<a hidden class="anchor" aria-hidden="true" href="#5连接的种类">#</a></h3>
<h3 id="6数据库优化的思路">6.数据库优化的思路<a hidden class="anchor" aria-hidden="true" href="#6数据库优化的思路">#</a></h3>
<h3 id="7存储过程与触发器的区别">7.存储过程与触发器的区别<a hidden class="anchor" aria-hidden="true" href="#7存储过程与触发器的区别">#</a></h3>
<h3 id="8悲观锁和乐观锁是什么">8.悲观锁和乐观锁是什么？<a hidden class="anchor" aria-hidden="true" href="#8悲观锁和乐观锁是什么">#</a></h3>
<h3 id="9你常用的mysql引擎有哪些各引擎间有什么区别">9.你常用的mysql引擎有哪些?各引擎间有什么区别?<a hidden class="anchor" aria-hidden="true" href="#9你常用的mysql引擎有哪些各引擎间有什么区别">#</a></h3>
<h2 id="redis">Redis<a hidden class="anchor" aria-hidden="true" href="#redis">#</a></h2>
<h3 id="1redis宕机怎么解决">1.Redis宕机怎么解决?<a hidden class="anchor" aria-hidden="true" href="#1redis宕机怎么解决">#</a></h3>
<p>宕机:服务器停止服务‘</p>
<p>如果只有一台redis，肯定 会造成数据丢失，无法挽救</p>
<p>多台redis或者是redis集群，宕机则需要分为在主从模式下区分来看：</p>
<p>slave从redis宕机，配置主从复制的时候才配置从的redis，从的会从主的redis中读取主的redis的操作日志1，在redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据;</p>
<p>2, 如果从数据库实现了持久化，此时千万不要立马重启服务，否则可能会造成数据丢失，正确的操作如下：在slave数据上执行SLAVEOF ON ONE,来断开主从关系并把slave升级为主库，此时重新启动主数据库，执行SLAVEOF，把它设置为从库，连接到主的redis上面做主从复制，自动备份数据。</p>
<p>以上过程很容易配置错误，可以使用redis提供的哨兵机制来简化上面的操作。简单的方法:redis的哨兵(sentinel)的功能</p>
<h3 id="2redis和mecached的区别以及使用场景">2.redis和mecached的区别，以及使用场景<a hidden class="anchor" aria-hidden="true" href="#2redis和mecached的区别以及使用场景">#</a></h3>
<p>区别</p>
<p>1、redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可以用于缓存其他东西，例如图片，视频等等</p>
<p>2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list,set,hash等数据结构的存储</p>
<p>3、虚拟内存-redis当物流内存用完时，可以将一些很久没用的value交换到磁盘</p>
<p>4、过期策略-memcache在set时就指定，例如set key1 0 0 8，即永不过期。Redis可以通过例如expire设定，例如expire name 10</p>
<p>5、分布式-设定memcache集群，利用magent做一主多从，redis可以做一主多从。都可以一主一丛</p>
<p>6、存储数据安全-memcache挂掉后，数据没了，redis可以定期保存到磁盘(持久化)</p>
<p>7、灾难恢复-memcache挂掉后，数据不可恢复，redis数据丢失后可以通过aof恢复</p>
<p>8、Redis支持数据的备份，即master-slave模式的数据备份</p>
<p>9、应用场景不一样，redis除了作为NoSQL数据库使用外，还能用做消息队列，数据堆栈和数据缓存等;Memcache适合于缓存SQL语句，数据集，用户临时性数据，延迟查询数据和session等</p>
<p>使用场景</p>
<p>1,如果有持久方面的需求或对数据类型和处理有要求的应该选择redis</p>
<p>2,如果简单的key/value存储应该选择memcached.</p>
<h3 id="3redis集群方案该怎么做都有哪些方案">3.Redis集群方案该怎么做?都有哪些方案?<a hidden class="anchor" aria-hidden="true" href="#3redis集群方案该怎么做都有哪些方案">#</a></h3>
<p>1,codis</p>
<p>目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在节点数量改变情况下，旧节点数据客恢复到新hash节点</p>
<p>2redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方介绍</p>
<p>3.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key进行hash计算，然后去对应的redis实例操作数据。这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的字典脚本恢复，实例的监控，等等</p>
<h3 id="4redis回收进程是如何工作的">4.Redis回收进程是如何工作的<a hidden class="anchor" aria-hidden="true" href="#4redis回收进程是如何工作的">#</a></h3>
<p>一个客户端运行了新的命令，添加了新的数据。</p>
<p>redis检查内存使用情况，如果大于maxmemory的限制，则根据设定好的策略进行回收。</p>
<p>一个新的命令被执行等等，所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断回收回到边界以下。</p>
<p>如果一个命令的结果导致大量内存被使用(例如很大的集合的交集保存到一个新的键)，不用多久内存限制就会被这个内存使用量超越。</p>
<h2 id="mongodb">MongoDB<a hidden class="anchor" aria-hidden="true" href="#mongodb">#</a></h2>
<h3 id="1mongodb中对多条记录做更新操作命令是什么">1.MongoDB中对多条记录做更新操作命令是什么？<a hidden class="anchor" aria-hidden="true" href="#1mongodb中对多条记录做更新操作命令是什么">#</a></h3>
<h3 id="2mongodb如何才会拓展到多个shard里">2.MongoDB如何才会拓展到多个shard里？<a hidden class="anchor" aria-hidden="true" href="#2mongodb如何才会拓展到多个shard里">#</a></h3>
<h2 id="测试">测试<a hidden class="anchor" aria-hidden="true" href="#测试">#</a></h2>
<h3 id="3编写测试计划的目的是">3.编写测试计划的目的是<a hidden class="anchor" aria-hidden="true" href="#3编写测试计划的目的是">#</a></h3>
<h3 id="4对关键词触发模块进行测试">4.对关键词触发模块进行测试<a hidden class="anchor" aria-hidden="true" href="#4对关键词触发模块进行测试">#</a></h3>
<h3 id="5其他常用笔试题目网址汇总">5.其他常用笔试题目网址汇总<a hidden class="anchor" aria-hidden="true" href="#5其他常用笔试题目网址汇总">#</a></h3>
<h3 id="6测试人员在软件开发过程中的任务是什么">6.测试人员在软件开发过程中的任务是什么<a hidden class="anchor" aria-hidden="true" href="#6测试人员在软件开发过程中的任务是什么">#</a></h3>
<h3 id="7一条软件bug记录都包含了哪些内容">7.一条软件Bug记录都包含了哪些内容？<a hidden class="anchor" aria-hidden="true" href="#7一条软件bug记录都包含了哪些内容">#</a></h3>
<h3 id="8简述黑盒测试和白盒测试的优缺点">8.简述黑盒测试和白盒测试的优缺点<a hidden class="anchor" aria-hidden="true" href="#8简述黑盒测试和白盒测试的优缺点">#</a></h3>
<h3 id="9请列出你所知道的软件测试种类至少5项">9.请列出你所知道的软件测试种类，至少5项<a hidden class="anchor" aria-hidden="true" href="#9请列出你所知道的软件测试种类至少5项">#</a></h3>
<h3 id="10alpha测试与beta测试的区别是什么">10.Alpha测试与Beta测试的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#10alpha测试与beta测试的区别是什么">#</a></h3>
<h3 id="11举例说明什么是bug一个bug-report应包含什么关键字">11.举例说明什么是Bug？一个bug report应包含什么关键字？<a hidden class="anchor" aria-hidden="true" href="#11举例说明什么是bug一个bug-report应包含什么关键字">#</a></h3>
<h2 id="大数据">大数据<a hidden class="anchor" aria-hidden="true" href="#大数据">#</a></h2>
<h3 id="1找出1g的文件中高频词">1.找出1G的文件中高频词<a hidden class="anchor" aria-hidden="true" href="#1找出1g的文件中高频词">#</a></h3>
<h3 id="2一个大约有一万行的文本文件统计高频词">2.一个大约有一万行的文本文件统计高频词<a hidden class="anchor" aria-hidden="true" href="#2一个大约有一万行的文本文件统计高频词">#</a></h3>
<h3 id="3怎么在海量数据中找出重复次数最多的一个">3.怎么在海量数据中找出重复次数最多的一个？<a hidden class="anchor" aria-hidden="true" href="#3怎么在海量数据中找出重复次数最多的一个">#</a></h3>
<h3 id="4判断数据是否在大量数据中">4.判断数据是否在大量数据中<a hidden class="anchor" aria-hidden="true" href="#4判断数据是否在大量数据中">#</a></h3>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://yurooc.github.io/tags/python/">Python</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://yurooc.github.io">YuBlog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div></footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
